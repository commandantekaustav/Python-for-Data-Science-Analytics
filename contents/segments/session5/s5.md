---
transition: slide-left
align: centre
title: Functions - Modularizing Your Code

layout: section
---

# Session 5: 
## Functions - Modularizing Your Code

---

## Session 5 - Welcome to Functions! üöÄ

**Welcome to Session 5: "Functions - Modularizing Your Code"!** üéâ

In the previous sessions, you've learned how to write programs with:

*   Basic Python syntax and data types
*   Clean and readable code (PEP 8)
*   Core Data Structures (Lists, Tuples, Dictionaries, Sets)
*   Control Flow (Conditional statements and Loops)

**Now, in Session 5, we're going to take a major step towards writing more organized, reusable, and efficient code by learning about **Functions**.**
---

## Session 5 - Welcome to Functions! üöÄ

**Welcome to Session 5: "Functions - Modularizing Your Code"!** üéâ

**In this session, we will explore:**

*   **What are Functions?**  Understanding the concept and benefits of functions.
*   **Defining Functions:**  Learning the syntax to create your own functions.
*   **Calling Functions:**  How to use and execute functions in your programs.
*   **Function Parameters and Arguments:**  Passing data to functions.
*   **`return` Values:**  Getting results back from functions.
*   **Function Scope (Introduction):**  Understanding variable scope within functions.
*   **Docstrings: Documenting your Functions:**  Writing clear function documentation.

**Functions are a fundamental building block in programming. They allow you to break down complex tasks into smaller, manageable, and reusable units, making your code more powerful, organized, and easier to work with!**

**Get ready to unlock the power of modularity and code reuse with Python Functions!** üí™

---

## What are Functions? ü§î

# What Exactly *Are* Functions?

**Imagine a function like a mini-program within your program!**  Think of them as self-contained blocks of code designed to perform a specific task.

**Key analogies to understand Functions:**

*   **Recipes:**  A recipe is a set of instructions to make a dish.  You give it ingredients (inputs), it follows the steps, and produces a dish (output).  Functions are like recipes for code.
*   **Machines/Tools:** A tool (like a calculator or a blender) performs a specific operation. You provide inputs (numbers, ingredients), and it performs its operation to give you a result (sum, smoothie). Functions are like specialized tools within your program.
*   **Black Boxes:**  You put something in (input), something happens inside (processing), and something comes out (output). You don't always need to know *how* it works inside, just *what* it does. Functions can be treated as "black boxes" that perform a defined operation.
---

## What are Functions? ü§î

# What Exactly *Are* Functions?

**In Programming Terms:**

*   **A function is a block of organized, reusable code that performs a specific task.**
*   Functions are defined once and can be **called (executed)** multiple times from different parts of your program.
*   They may accept **inputs** (called arguments or parameters) and may produce **outputs** (return values).
*   Functions help break down complex programs into smaller, more manageable, and logical modules.

**Why are Functions Important?  Let's explore the benefits on the next slide!** ‚û°Ô∏è

---

## Why Use Functions? ü§î

# Why are Functions *So* Important? - The Benefits

Functions are not just a nice-to-have feature; they are **essential for writing good, maintainable, and scalable code.**  Let's look at the key benefits:

**1. Code Reusability:**

*   **Write once, use many times:** Define a function to perform a task, and then call that function whenever you need to perform that task again in your program.
*   **Avoid redundant code:**  No need to copy and paste the same code blocks repeatedly. This reduces code duplication and makes your code shorter and cleaner.
*   **Example:** Imagine you need to calculate the area of a circle multiple times in your program. You can write a function `calculate_circle_area(radius)` once, and then call it whenever you need to calculate the area with different radii.
---

## Why Use Functions? ü§î

# Why are Functions *So* Important? - The Benefits

Functions are not just a nice-to-have feature; they are **essential for writing good, maintainable, and scalable code.**  Let's look at the key benefits:

**2. Code Organization and Modularity:**

*   **Break down complex problems:** Functions help you divide a large, complex program into smaller, logical, and self-contained modules (the functions).
*   **Improved structure:**  Makes your code easier to understand, read, and navigate.  Instead of one long, monolithic block of code, you have well-defined, named sections.
*   **Easier to manage and maintain:**  Smaller, modular functions are easier to test, debug, and modify independently without affecting other parts of the program.
---

## Why Use Functions? ü§î

# Why are Functions *So* Important? - The Benefits

Functions are not just a nice-to-have feature; they are **essential for writing good, maintainable, and scalable code.**  Let's look at the key benefits:

**3. Abstraction (Simplifying Complexity):**

*   **Focus on *what* not *how*:** Functions allow you to abstract away the implementation details of a task. When you *use* a function, you only need to know *what* it does (its purpose and inputs/outputs), not *how* it does it internally.
*   **Simplifies code usage:**  This makes your code cleaner and easier to use. You can use a function without being bogged down in its internal workings.
*   **Example:** When you use the `print()` function, you don't need to know the complex steps Python takes to display text on the screen. You just know *what* `print()` does: it displays output.
---

## Why Use Functions? ü§î

# Why are Functions *So* Important? - The Benefits

Functions are not just a nice-to-have feature; they are **essential for writing good, maintainable, and scalable code.**  Let's look at the key benefits:


**4. Readability and Understandability:**

*   **Meaningful function names:** Well-named functions act like descriptive labels for code blocks, making it much easier to understand what the code is doing at a glance.
*   **Logical flow:**  Code that is organized into functions is often easier to follow and understand the overall logic of the program.
*   **Improved communication:** Functions make it easier for others (and your future self!) to understand your code.

**In essence, functions are crucial for writing professional, efficient, and maintainable Python code. They are a fundamental tool for any programmer!** ‚ú®

**Next: Let's learn how to actually *define* functions in Python!** ‚û°Ô∏è

---
layout: two-cols-header
---

## Defining Simple Functions - Examples üöÄ
# Defining Functions:  Quick Examples

**Let's define a few simple functions to illustrate the syntax.**
::left::
**Example 1: A greeting function (no parameters, no return)**

```python
def greet():
    """Prints a simple greeting message."""
    print("Hello there!")

# That's it! Function definition is done.
```

**Example 2: Function to add two numbers (with parameters, returns a value)**

```py
def add_numbers(num1, num2):
    """Adds two numbers and returns the sum."""
    sum_result = num1 + num2
    return sum_result # Returns the calculated sum
```
::right::
**Example 3: Function to check if a number is even (with parameter, returns boolean)**

```python
def is_even(number):
    """Checks if a number is even and returns True or False."""
    if number % 2 == 0:
        return True
    else:
        return False
    # More concisely:  return number % 2 == 0
```
---

## Defining Simple Functions - Examples üöÄ
# Defining Functions:  Quick Examples

**Key points from examples:**

- `def` **keyword** always starts function definition.
- **Function name** follows `def` (e.g., `greet`, `add_numbers`, `is_even`).
- **Parentheses** `()` after function name, may contain parameters (inputs).
- **Colon** `:` ends the `def` line.
- **Indented body** contains function code.
- `return` sends a value back (optional, `greet()` has no `return`).
- **Docstrings** explain what the function does (good practice).

**Next: How do we actually use (call) these functions? Let's find out!** ‚û°Ô∏è

---
layout: two-cols-header
---

## Calling Functions üìû

# Calling (Executing) Your Functions

**Defining a function just creates it. To actually *use* a function and execute the code inside it, you need to **call** the function.**

::left::
**How to Call a Function:**

*   To call a function, you use its **name** followed by **parentheses `()`**.
*   If the function expects **arguments** (parameters), you provide the argument values inside the parentheses.
**Syntax for Calling a Function:**

```python
function_name(arguments)
```
::right::

- `function_name`**:** The name of the function you want to execute.
- `()` **Parentheses:** Always needed when calling a function, even if it takes no arguments.
- **`arguments` (optional):** Values you are passing to the function's parameters. Arguments should match the number and type of parameters the function expects (if any).
---

## Calling Functions üìû

# Calling (Executing) Your Functions

**Defining a function just creates it. To actually *use* a function and execute the code inside it, you need to **call** the function.**

**Examples - Calling the functions we defined earlier:**

```py
# Calling the greet() function (no arguments needed)
greet() # Executes the code inside the greet() function
# Output: Hello there!


# Calling the add_numbers() function (needs two arguments)
result_sum = add_numbers(5, 3) # Passes 5 as num1, 3 as num2, gets back the returned sum
print(result_sum) # Output: 8


# Calling the is_even() function (needs one argument)
check_even = is_even(10) # Passes 10 as 'number', gets back True or False
print(check_even) # Output: True

check_odd = is_even(7)
print(check_odd) # Output: False
```
---

## Calling Functions üìû

# Calling (Executing) Your Functions

**Defining a function just creates it. To actually *use* a function and execute the code inside it, you need to **call** the function.**

**Explanation:**

- When you call a function (like `greet()`), the program execution jumps to the code inside the function definition.
- The code within the function's body is executed.
- If the function has a `return` statement, it sends a value back to the point where the function was called. This returned value can be stored in a variable (like `result_sum = ...`).
- After the function finishes executing (or reaches a `return` statement), the program execution returns to the line *immediately* after the function call.


**Next: Let's explore function parameters and arguments in more detail! ‚û°Ô∏è**

---
layout: two-cols-header
---

### Function Parameters and Arguments üì•üì§
# Function Parameters and Arguments:  Giving Input to Functions

**Functions become more powerful when they can accept inputs and work with different data. This is done using **parameters** when defining the function and **arguments** when calling it.**
::left::
**Parameters (in Function Definition):**

*   **Placeholders for input:** Parameters are variables listed inside the parentheses `()` in the function definition.
*   **Define expected inputs:** They act as names for the input values the function expects to receive.
*   **Local variables:** Parameters become local variables within the function's scope.
::right::
**Arguments (in Function Call):**

*   **Actual input values:** Arguments are the *actual values* you pass to the function when you call it.
*   **Passed to parameters:** These argument values are assigned to the corresponding parameters in the function definition.
*   **Provide data for processing:** Arguments provide the specific data the function will work with in that particular call.
---

### Function Parameters and Arguments üì•üì§
# Function Parameters and Arguments:  Giving Input to Functions

**Analogy: Think of Parameters as labeled "slots" in a machine, and Arguments as the actual "items" you put into those slots when you use the machine.**

**Example - Function with Parameters and Arguments:**

```python
def calculate_power(base, exponent): # 'base' and 'exponent' are parameters
    """Calculates the power of a number (base raised to exponent)."""
    result = base ** exponent
    return result

# Calling the function with arguments:
power_of_2 = calculate_power(2, 3) # 2 and 3 are arguments passed to 'base' and 'exponent'
print(power_of_2) # Output: 8  (2 raised to the power of 3)

power_of_5 = calculate_power(5, 2) # 5 and 2 are arguments
print(power_of_5) # Output: 25 (5 raised to the power of 2)
```
---

### Function Parameters and Arguments üì•üì§
# Function Parameters and Arguments:  Giving Input to Functions

**Explanation:**

1. In `def calculate_power(base, exponent):`, `base` and `exponent` are parameters - they are placeholders for input.
2. When we call `calculate_power(2, 3)`, `2` is the argument passed to the `base` parameter, and `3` is the argument passed to the `exponent` parameter.
3. Inside the function, `base` now holds the value `2`, and `exponent` holds `3`.
4. The function calculates `2 ** 3` (2 to the power of 3) and returns the result.
5. Similarly, in `calculate_power(5, 2)`, 5 and 2 are arguments passed to the parameters.

**Next: Let's explore different types of parameters and how to use them effectively! ‚û°Ô∏è**

---

## Types of Function Parameters ‚öôÔ∏è
# Types of Function Parameters in Python

**Python offers flexibility in how you define parameters in your functions. Let's look at the common types:**

**1. Positional Arguments:**

*   **Most common type.** Arguments are passed to parameters based on their **position** in the function call.
*   **Order matters!** The first argument matches the first parameter, the second argument matches the second parameter, and so on.

    ```python
    def describe_pet(animal_type, pet_name):
        """Displays information about a pet."""
        print(f"I have a {animal_type} named {pet_name}.")

    describe_pet("hamster", "Harry") # "hamster" is assigned to animal_type, "Harry" to pet_name
    # Output: I have a hamster named Harry.
    describe_pet("Harry", "hamster") # Order reversed! "Harry" now assigned to animal_type, "hamster" to pet_name
    # Output: I have a Harry named hamster.  (Order matters!)
    ```
---

## Types of Function Parameters ‚öôÔ∏è
# Types of Function Parameters in Python

**Python offers flexibility in defining parameters in your functions. Let's look at the common types:**

**2. Keyword Arguments:**

*   Arguments are passed with **keywords** (parameter names) explicitly specified in the function call.
*   **Order doesn't matter!** You can pass keyword arguments in any order by specifying the param-name.
*   Often improves code readability, especially for functions with many parameters.

    ```python
    def describe_pet(animal_type, pet_name):
        """Displays information about a pet."""
        print(f"I have a {animal_type} named {pet_name}.")

    describe_pet(pet_name="Harry", animal_type="hamster") # Order doesn't matter with keywords
    # Output: I have a hamster named Harry.

    describe_pet(animal_type="dog", pet_name="Buddy") # Keyword arguments enhance clarity
    # Output: I have a dog named Buddy.
    ```
---

## Types of Function Parameters ‚öôÔ∏è
# Types of Function Parameters in Python

**Python offers flexibility in defining parameters in your functions. Let's look at the common types:**
**3. Default Parameter Values:**

*   You can specify **default values** for parameters in the function definition.
*   If no argument is provided for a parameter with a default value in the function call, the default value is used.
*   Makes parameters optional and functions more flexible.

    ```python
    def greet_user(name, greeting="Hello"): # 'greeting' has a default value "Hello"
        """Greets a user with an optional greeting message."""
        print(f"{greeting}, {name}!")

    greet_user("Alice") # 'greeting' uses default value "Hello"
    # Output: Hello, Alice!

    greet_user("Bob", greeting="Good morning") # Override default 'greeting'
    # Output: Good morning, Bob!
    ```
---

## Types of Function Parameters ‚öôÔ∏è
# Types of Function Parameters in Python

**Python offers flexibility in defining parameters in your functions. Let's look at the common types:**

**4. (Later) `*args` and `**kwargs` (for variable number of arguments):** We'll cover these powerful features in a later slide!

**Understanding these parameter types gives you great control over how functions accept and process inputs!**

**Next: Let's practice using different parameter types with a "Your Turn" exercise!** ‚û°Ô∏è

---

## Your Turn: Function Parameter Exercise ‚úçÔ∏è‚öôÔ∏è
# Your Turn!  Function Parameter Exercise

**Time to practice defining and calling functions with different types of parameters!**

**Exercise 1:  Personalized Greeting Function**

**Task:** Write a Python function called `create_greeting` that:

1.  Takes two parameters: `name` and `message`.
2.  Creates a personalized greeting message string in the format:  `"Hello [name], [message]"`
3.  **Returns** the greeting message string.

   Example: `create_greeting("Alice", "Have a great day!")` should return `"Hello Alice, Have a great day!"`
---

## Your Turn: Function Parameter Exercise ‚úçÔ∏è‚öôÔ∏è
# Your Turn!  Function Parameter Exercise

**Time to practice defining and calling functions with different types of parameters!**

**Exercise 2:  Order Total Calculator with Default Parameter**

**Task:** Write a Python function called `calculate_total_price` that:

1.  Takes two parameters:
    *   `price`: The price of an item.
    *   `quantity`: The quantity of items (with a **default value of 1**).
2.  Calculates the total price (price * quantity).
3.  **Returns** the total price.

   Example:
   *  `calculate_total_price(10, 3)` should return `30`
   *  `calculate_total_price(25)` should return `25` (using the default quantity of 1).
---

## Your Turn: Function Parameter Exercise ‚úçÔ∏è‚öôÔ∏è
# Your Turn!  Function Parameter Exercise

**Time to practice defining and calling functions with different types of parameters!**

**Exercise 3:  Calling and Experimenting**

1.  In your Jupyter Notebook, define both the `create_greeting` and `calculate_total_price` functions.
2.  Call `create_greeting` using **positional arguments**.
3.  Call `create_greeting` using **keyword arguments** (in a different order than the parameters are defined).
4.  Call `calculate_total_price` with both `price` and `quantity` arguments.
5.  Call `calculate_total_price` with only the `price` argument (relying on the default `quantity`).
6.  Print the results of each function call to verify they are working correctly.

**Take a few minutes to complete these exercises in your Jupyter Notebook. Then we'll move on to discuss function return values! ‚úçÔ∏è**

---

### Function `return` Values ‚Ü©Ô∏è
# Function `return` Values: Getting Output from Functions

**Functions are often designed to perform a calculation or some processing and then give you back a result.  This is done using the `return` statement.**

**Purpose of `return`:**

*   **Specify the output:** The `return` statement in a function specifies what value(s) the function should send back to the caller (the part of the code that called the function).
*   **End function execution:** When a `return` statement is executed, the function immediately stops running, and the value specified in the `return` statement is passed back.
---

### Function `return` Values ‚Ü©Ô∏è
# Function `return` Values: Getting Output from Functions
<br>

**Syntax of `return`:**

```python
return expression  # 'expression' is the value to be returned
```

- **`return` keyword:** Signals that the function should return a value.
- **`expression` (optional):** The value you want the function to return. This can be a variable, a literal value, a calculation, or even another function call. If no `expression` is provided, or if there is no `return` statement at all, the function implicitly returns `None`.
---

### Function `return` Values ‚Ü©Ô∏è
# Function `return` Values: Getting Output from Functions

**Examples - Functions with `return` values:**

```py
def multiply(x, y):
    """Multiplies two numbers and returns the product."""
    product = x * y
    return product # Returns the calculated product

result = multiply(4, 6) # Call multiply(), returned value is stored in 'result'
print(result) # Output: 24


def get_greeting(name):
    """Returns a greeting string."""
    greeting_message = f"Hello, {name}!"
    return greeting_message # Returns the greeting string

greeting = get_greeting("Charlie") # Returned string is stored in 'greeting'
print(greeting) # Output: Hello, Charlie!
```
---

### Function `return` Values ‚Ü©Ô∏è
# Function `return` Values: Getting Output from Functions

**Example - Function *without* explicit `return` (implicitly returns `None`):**

```py
def print_message(text):
    """Prints a message to the console. No return value."""
    print(text)
    # No 'return' statement here

output = print_message("This function prints only.") # Call print_message()
print(output) # Output: None (function implicitly returns None)
```
---

### Function `return` Values ‚Ü©Ô∏è
# Function `return` Values: Getting Output from Functions

**Key Points:**

- Functions can return values of **any data type** (numbers, strings, lists, tuples, dictionaries, booleans, etc.), or even multiple values (as a tuple).
- Using `return` is essential when you want a function to produce a result that you can use in other parts of your program.
- If you don't need a function to `return` a specific value, you can omit the return statement (it will then return `None` implicitly).

**Next: Let's dive into function scope and understand how variables behave inside functions! ‚û°Ô∏è**

---

## Function Scope - Local Variables üè†
# Function Scope:  Where Variables Live - Local Variables

**Scope refers to the region of your program where a variable is accessible or can be used.** Functions define their own scope. Let's focus on **local variables** within function scope.

**Local Variables:**

*   **Defined *inside* a function:** Variables that are created and assigned a value *within* a function's body are considered local variables.
*   **Exist only within the function:** Local variables are only accessible and exist *inside* the function in which they are defined. They cannot be accessed or used from outside the function.
*   **Lifetime:** Local variables are created when the function is called, and they are destroyed (cease to exist) when the function finishes executing (returns or completes).
---

### Function Scope - Local Variables üè†
# Function Scope:  Where Variables Live - Local Variables

**Scope refers to the region of your program where a variable is accessible or can be used.** Functions define their own scope. Let's focus on **local variables** within function scope.

**Example - Local Variable Scope:**

```python
def my_function():
    """Demonstrates local variable scope."""
    message = "Hello from inside the function!" # 'message' is a local variable
    print(message)

my_function() # Calling the function - local variable 'message' is created and used here
# Output: Hello from inside the function!

# print(message) # This would cause an ERROR! 'message' is not defined outside the function
# NameError: name 'message' is not defined
```
---

### Function Scope - Local Variables üè†
# Function Scope:  Where Variables Live - Local Variables

**Scope refers to the region of your program where a variable is accessible or can be used.** Functions define their own scope. Let's focus on **local variables** within function scope.

**Explanation:**

1. Inside `my_function()`, we define a variable `message`. This makes `message` a **local variable**.
2. `message` is accessible and can be used within the code block of `my_function()`.
3. When `my_function()` is called, the local variable `message` is created in memory.
4. After `my_function()` finishes executing, the local variable `message` is destroyed and no longer exists.
5. Trying to access `message` *outside* of `my_function()` (e.g., in the commented-out `print(message)`) results in a `NameError` because `message` is not defined in that scope (it's local to the function).
---

### Function Scope - Local Variables üè†
# Function Scope:  Where Variables Live - Local Variables
<br>

**Key takeaway: Variables defined inside a function are contained within that function's scope and are not directly accessible from the outside.**

**Next: Let's contrast local variables with global variables and understand the difference! ‚û°Ô∏è**

---

### Function Scope - Global vs. Local üåçüè†
# Function Scope: Global vs. Local Variables - Understanding the Difference

**Now let's contrast **local variables** with **global variables** and understand how scope works in Python.**

**Global Variables:**

*   **Defined *outside* any function:** Variables that are defined in the main body of your Python script (i.e., not inside any function definition) are considered global variables.
*   **Accessible from *anywhere* in the script:** Global variables can be accessed and used from both outside of functions and *inside* functions (with some considerations).
*   **Lifetime:** Global variables are created when the program starts and generally exist until the program finishes execution.
---

### Function Scope - Global vs. Local üåçüè†
# Function Scope: Global vs. Local Variables - Understanding the Difference
<br>

**Local Variables (Recap):**

*   **Defined *inside* a function.**
*   **Accessible *only* within that function.**
*   **Created when the function is called, destroyed when it finishes.**
---

### Function Scope - Global vs. Local üåçüè†
# Function Scope: Global vs. Local Variables - Understanding the Difference

**Example - Global and Local Variables:**

```python
global_variable = "I am a global variable" # Defined outside any function - GLOBAL

def my_function():
    """Demonstrates global and local variable scope."""
    local_variable = "I am a local variable" # Defined inside function - LOCAL
    print(local_variable)       # Accessing local variable (OK)
    print(global_variable)      # Accessing global variable (OK)

my_function()
# Output:
# I am a local variable
# I am a global variable

print(global_variable)         # Accessing global variable outside function (OK)
# print(local_variable)        # This would cause an ERROR! Local variable not accessible here
# NameError: name 'local_variable' is not defined
```
---

### Function Scope - Global vs. Local üåçüè†
# Function Scope: Global vs. Local Variables - Understanding the Difference

**Modifying Global Variables Inside a Function (Need `global` keyword):**

- If you want to **modify** the value of a global variable *from within a* function, you need to use the `global` keyword inside the function to explicitly declare your intent to work with the global variable.
- Without `global`, assigning to a variable inside a function will *always* create a *new local variable*, even if a global variable with the same name exists.
---
layout: two-cols-header
---

### Function Scope - Global vs. Local üåçüè†
# Function Scope: Global vs. Local Variables - Understanding the Difference

```py
global_counter = 0

def increment_counter():
    """Increments the global counter."""
    # Declare intent to modify the GLOBAL 'global_counter'
    global global_counter 
    global_counter = global_counter + 1
    print(f"Counter incremented to: {global_counter}")

# Calls the function - modifies the global variable
increment_counter() 
# Calls again - global variable is modified again
increment_counter() 

print(f"Final global counter value: {global_counter}")
# Output: 2
```
---

### Function Scope - Global vs. Local üåçüè†
# Function Scope: Global vs. Local Variables - Understanding the Difference

**Best Practice - Minimize Global Variables:**

- While global variables are technically possible, it's generally considered good practice to **minimize their use**.
- Excessive use of global variables can make code harder to understand, debug, and maintain, especially in larger programs.
- **Favor passing data into functions as arguments and returning values** to keep functions self-contained and make code more modular and predictable.

**Next: Let's learn about documenting your functions using Docstrings - essential for code clarity! ‚û°Ô∏è**

---

## Docstrings - Documenting Your Functions üìù
# Docstrings:  Documenting Your Functions - Explain What Your Functions Do!

**Docstrings (documentation strings) are essential for making your functions (and code in general) understandable and maintainable.** They are used to provide in-code documentation that explains what a function does, its parameters, and what it returns.

**What are Docstrings?**

*   **String literals in triple quotes `"""Docstring goes here"""`:** Docstrings are simply strings enclosed in triple quotes (`"""` or `'''`).
*   **First statement in a function:** They must be the very first statement inside a function definition, right after the `def` line.
*   **Function's documentation:**  Python uses docstrings to generate help text and documentation for your functions.
---

### Docstrings - Documenting Your Functions üìù
# Docstrings:  Documenting Your Functions - Explain What Your Functions Do!
<br>

**Why Use Docstrings?**

*   **Explain function purpose:**  Docstrings clearly describe what a function is intended to do.
*   **Describe parameters and return values:**  They document what parameters the function accepts and what type of value it returns.
*   **Help other developers (and yourself!):**  Docstrings make it easier for others to understand how to use your functions (and for you to remember what your code does when you revisit it later!).
*   **Automatic documentation:**  Documentation tools can automatically extract docstrings to generate documentation for your code.
*   **Accessible via `help()`:**  You can access a function's docstring using the built-in `help(function_name)` function or by accessing the `__doc__` attribute (e.g., `function_name.__doc__`).
---

### Docstrings - Documenting Your Functions üìù
# Docstrings:  Documenting Your Functions - Explain What Your Functions Do!
<br>

**Example - Function with a Docstring:**

```python
def calculate_area_rectangle(length, width):
    """
    Calculates the area of a rectangle.

    Parameters:
    length (number): The length of the rectangle.
    width (number): The width of the rectangle.

    Returns:
    number: The calculated area of the rectangle (length * width).
    """
    area = length * width
    return area
```
---

### Docstrings - Documenting Your Functions üìù
# Docstrings:  Documenting Your Functions - Explain What Your Functions Do!
<br>

**Accessing Docstrings:**
```py
help(calculate_area_rectangle) # Displays the docstring in help format

print(calculate_area_rectangle.__doc__) # Prints the raw docstring string
```
---

### Docstrings - Documenting Your Functions üìù
# **Docstring Conventions (PEP 257):**

- **First line: Concise summary:** The first line should be a brief summary of the function's purpose. It should be on a single line and start with a capital letter and end with a period.
- **Blank line after summary:** Leave a blank line after the summary line.
- **More detailed explanation (optional):** For more complex functions, you can add a more detailed explanation after the blank line, including parameter descriptions, return value details, examples, etc.

**Good docstrings are a hallmark of well-written Python code.  Make it a habit to document your functions! ‚ú®**

**Next: Let's practice writing functions with docstrings in a "Your Turn" exercise! ‚û°Ô∏è**

---
layout: two-cols-header
---

## Function Exercises ‚úçÔ∏è
# Your Turn!  Function Exercises - Putting it all Together

**Time to solidify your understanding of functions with these exercises!**
::left::
**Exercise 1:  Calculate Rectangle Perimeter**

**Task:** Write a Python function called `calculate_perimeter` that:

1.  Takes two parameters: `length` and `width` of a rectangle.
2.  Calculates the perimeter of the rectangle (`2 * (length + width)`).
3.  **Returns** the calculated perimeter.
4.  **Include a docstring** to explain what the function does, its parameters, and what it returns.
::right::
**Exercise 2:  String Reverser**

**Task:** Write a Python function called `reverse_string` that:

1.  Takes one parameter: `text` (a string).
2.  Reverses the input string. (Hint: string slicing `[::-1]` is a concise way to reverse a string in Python).
3.  **Returns** the reversed string.
4.  **Include a docstring**.
---
layout: two-cols-header
---

### Function Exercises ‚úçÔ∏è
# Your Turn!  Function Exercises - Putting it all Together

**Time to solidify your understanding of functions with these exercises!**
::left::
**Exercise 3:  Temperature Converter (Celsius to Fahrenheit)**

**Task:** Write a Python function called `celsius_to_fahrenheit` that:

1.  Takes one parameter: `celsius_temp` (temperature in Celsius).
2.  Converts Celsius to Fahrenheit using the formula:  `Fahrenheit = (Celsius * 9/5) + 32`
3.  **Returns** the temperature in Fahrenheit.
4.  **Include a docstring**.
::right::
**Exercise 4:  Calling and Testing**

1.  Define all three functions (`calculate_perimeter`, `reverse_string`, `celsius_to_fahrenheit`) in your Jupyter Notebook.
2.  Call each function with different inputs and print the returned results to test if they work correctly.
3.  Use the `help()` function (or `.__doc__` attribute) to display the docstrings you wrote for each function and verify they are informative.


**Practice is the key to mastering functions! üöÄ**

---


### Introduction to `*args` - Variable Positional Arguments ‚öôÔ∏è
#  `*args`: Functions with Variable Number of Positional Arguments

**What if you want to create a function that can accept a *variable number* of positional arguments?  This is where `*args` comes in!**

**`*args` (pronounced "star args"):**

*   **Special syntax in function definition:**  The `*args` syntax in a function parameter list allows a function to accept **any number of positional arguments**.
*   **Collects arguments into a tuple:**  Python gathers all the positional arguments passed in the function call into a **tuple** named `args` (you can actually choose any valid variable name after the `*`, but `args` is convention).
*   **Access arguments as a tuple:** Inside the function, you can access and iterate over the arguments using the `args` tuple.
---
layout: two-cols-header
---

### Introduction to `*args` - Variable Positional Arguments ‚öôÔ∏è
#  `*args`: Functions with Variable Number of Positional Arguments

**What if you want to create a function that can accept a *variable number* of positional arguments?  This is where `*args` comes in!**

::left::

**Syntax:**

```python
def function_name(*args):
    """Function docstring."""
    # Function body - access arguments via the 'args' tuple
    for arg in args: # Iterate through the arguments
        # ... process each argument ...
        pass
    # ... rest of function code ...
```

::right::

- `*args` **parameter:** The `*` before the parameter name is what's crucial. It indicates variable positional arguments.
- `args` **(variable name):** By convention, we use `args`, but you could use other valid variable names (like `*numbers`, `*items`, etc.). Choose a descriptive name.
---
layout: two-cols-header
---

### Introduction to `*args` - Variable Positional Arguments ‚öôÔ∏è
<!-- #  `*args`: Functions with Variable Number of Pos-Args -->

::left::
**Example - Function to sum any number of arguments:**
```py
def sum_all_numbers(*args):
    """Sums up any number of numbers passed as arguments."""
    total = 0

    # Iterate through the 'args' tuple
    for number in args: 
        total += number
    return total

# Calling sum_all_numbers with different numbef of args:
result1 = sum_all_numbers(1, 2, 3)
print(result1) # Output: 6

result2 = sum_all_numbers(10, 20, 30, 40, 50)
print(result2) # Output: 150

result3 = sum_all_numbers() # Calling with no arguments
print(result3) # Output: 0 (empty tuple, sum is 0)
```
::right::
**Explanation:**

- The `sum_all_numbers(*args)` function can take any number of arguments.
- Inside the function, `args` becomes a tuple containing all the arguments passed in the call.
- We can then iterate through the `args` tuple to process each argument (here; summing them up).

**`*args` is very useful when you want to create functions that are flexible and can handle a varying amount of input data!**

**Next: Let's explore \*\*kwargs for variable keyword arguments! ‚û°Ô∏è**

---

### Introduction to `**kwargs` - Variable Keyword Arguments ‚öôÔ∏è
# `**kwargs`: Functions with Variable Number of Keyword Arguments

**Now, let's consider functions that need to accept a *variable number* of **keyword arguments**. This is where `**kwargs` comes in!**

**`**kwargs` (pronounced "double star kwargs"):**

*   **Special syntax for keyword arguments:**  The `**kwargs` syntax in a function parameter list enables a function to accept **any number of keyword arguments**.
*   **Collects keyword arguments into a dictionary:** Python gathers all the keyword arguments passed in the function call into a **dictionary** named `kwargs` (again, `kwargs` is just a convention).
*   **Access arguments as a dictionary:**  Inside the function, you can access and work with the keyword arguments using the `kwargs` dictionary (e.g., iterate through keys and values, access values by key).
---

### Introduction to `**kwargs` - Variable Keyword Arguments ‚öôÔ∏è
# `**kwargs`: Functions with Variable Number of Keyword Arguments

**Syntax:**

```python
def function_name(**kwargs):
    """Function docstring."""
    # Function body - access keyword arguments via the 'kwargs' dictionary
    for key, value in kwargs.items(): # Iterate through key-value pairs in kwargs
        # ... process each keyword argument (key and value) ...
        pass
    # ... rest of function code ...
```

- **`**kwargs` parameter:** The `**` before the parameter name is key. It signals variable keyword arguments.
- **`kwargs` (variable name):** Conventionally kwargs, but you could use other valid names (like `**options`, `**config`, etc.).
---

### Introduction to `**kwargs` - Variable Keyword Arguments ‚öôÔ∏è
<!-- # `**kwargs`: Functions with Variable Number of Keyword Arguments -->

**Example - Function to process keyword arguments:**

```py
def process_user_info(**kwargs):
    """Processes and prints user information from keyword arguments."""
    for key, value in kwargs.items():
        print(f"Key: {key}, Value: {value}")

# Calling process_user_info with different keyword arguments:
process_user_info(name="Alice", age=30, city="New York")
# Output:
# Key: name, Value: Alice
# Key: age, Value: 30
# Key: city, Value: New York


process_user_info(language="Python", level="Beginner")
# Output:
# Key: language, Value: Python
# Key: level, Value: Beginner


process_user_info() # Calling with no keyword arguments - kwargs is an empty dictionary
# (No output from the loop)
```
---

### Introduction to `**kwargs` - Variable Keyword Arguments ‚öôÔ∏è
# `**kwargs`: Functions with Variable Number of Keyword Arguments
<br>

**Explanation:**
- `process_user_info(**kwargs)` can accept any number of keyword arguments.
- Inside, `kwargs` becomes a dictionary where keys are the argument keywords (e.g., "name", "age") and values are the argument values (e.g., "Alice", 30).
- We can then iterate through the `kwargs` dictionary to access and process each keyword argument.

**`**kwargs` is very useful for creating functions that are highly configurable and can accept optional settings or parameters passed as keywords!**

**Next:  Let's see how `*args` and `**kwargs` can be combined in a single function definition! ‚û°Ô∏è**
---

### Combining `*args` and `**kwargs` ü§ù
# Combining `*args` and `**kwargs` in One Function

**You can design functions that accept both variable positional arguments (`*args`) AND variable keyword arguments (`**kwargs`) in the *same function definition!**

**Order of Parameters is Important:**

When you combine `*args` and `**kwargs`, they must be in this specific order in the function definition:

1.  **Standard positional parameters** (if any, like `param1, param2`)
2.  **`*args`** (to capture any extra positional arguments)
3.  **Standard keyword-only parameters** (less common, but possible - we won't focus on these now)
4.  **`**kwargs`** (to capture any extra keyword arguments)
---
layout: two-cols-header
---

### Combining `*args` and `**kwargs` ü§ù
# Combining `*args` and `**kwargs` in One Function

**You can design functions that accept both variable positional arguments (`*args`) AND variable keyword arguments (`**kwargs`) in the *same* function definition!**

**General Syntax for Combined Parameters:**

```python
def my_function(param1, param2, *args, **kwargs):
    """Function docstring."""
    print("Standard parameters:", param1, param2)
    print("*args (positional arguments tuple):", args)
    print("**kwargs (keyword arguments dictionary):", kwargs)
    # ... function logic using param1, param2, args, kwargs ...
```

<!-- ### Combining `*args` and `**kwargs` ü§ù
# Combining `*args` and `**kwargs` in One Function -->

**Example - Function accepting both `*args` and `**kwargs`:**

```py
def example_function(title, *args, **kwargs):
    """Demonstrates combining *args and **kwargs."""
    print(f"Title: {title}")
    print("*args (positional arguments):", args)
    print("**kwargs (keyword arguments):", kwargs)
    print("-" * 20) # Separator
```
---

### Combining `*args` and `**kwargs` ü§ù
# Combining `*args` and `**kwargs` in One Function

**Example - Function accepting both `*args` and `**kwargs`:**

```bash
example_function("Function Call 1", 10, 20, 30, option1="value1", option2="value2")
# Output:
# Title: Function Call 1
# *args (positional arguments): (10, 20, 30)
# **kwargs (keyword arguments): {'option1': 'value1', 'option2': 'value2'}
# --------------------
example_function("Function Call 2", "hello", "world", setting="on")
# Output:
# Title: Function Call 2
# *args (positional arguments): ('hello', 'world')
# **kwargs (keyword arguments): {'setting': 'on'}
# --------------------
example_function("Function Call 3") # Only title argument provided
# Output:
# Title: Function Call 3
# *args (positional arguments): ()
# **kwargs (keyword arguments): {}
# --------------------
```

---

### Combining `*args` and `**kwargs` ü§ù
# Combining `*args` and `**kwargs` in One Function

**Example - Function accepting both `*args` and `**kwargs`:**

**Explanation:**

- `example_function` is defined to take a standard positional parameter `title`, followed by `*args`, and then `**kwargs`.
- In function calls, arguments are matched in order:
    - The first argument is assigned to `title`.
    - Any extra positional arguments are packed into the `args` tuple.
    - Any keyword arguments are packed into the `kwargs` dictionary.

**Combining `*args` and `**kwargs` provides maximum flexibility for your functions to accept a wide range of inputs!**

**Next: Let's do a "Your Turn" exercise to practice using `*args` and `**kwargs`! ‚û°Ô∏è**

---
layout: two-cols-header
---

### Your Turn: `*args` and `**kwargs` Exercises ‚úçÔ∏è
# Your Turn! `*args` and `**kwargs` Exercises
**Let's practice using `*args` and `**kwargs` to create flexible functions!**

::left::
**Exercise 1:  Product of Numbers with `*args`**
**Task:** Write a Python function called `calculate_product` that:

1.  Accepts a variable number of positional arguments using `*args`.
2.  Calculates and **returns** the product of all the numbers passed in `*args`.
3.  If no arguments are passed, it should return `1`; <br> (the multiplicative identity).
::right::
**Example:**

*  `calculate_product(2, 3)` should return `6`
*  `calculate_product(1, 2, 3, 4)` should return `24`
*  `calculate_product(5)` should return `5`
*  `calculate_product()` should return `1`
---
layout: two-cols-header
---

### Your Turn: `*args` and `**kwargs` Exercises ‚úçÔ∏è
# Your Turn! `*args` and `**kwargs` Exercises
**Let's practice using `*args` and `**kwargs` to create flexible functions!**

::left::

**Exercise 2:  Display User Profile with `**kwargs`**

**Task:** Write a Python function called `display_profile` that:

1.  Accepts a variable number of keyword arguments using `**kwargs`. These keyword arguments will represent user profile information (like `name`, `city`, `age`, `occupation`, etc.).
2.  Prints out the user profile information in a readable format, displaying each key-value pair from `**kwargs`.

::right::

   Example:
   *  `display_profile(name="Alice", age=30)` should print something like:
      ```
      User Profile:
      name: Alice
      age: 30
      ```
   <!-- *  `display_profile(username="Bob", city="London", occupation="Engineer")` should print:
      ```
      User Profile:
      username: Bob
      city: London
      occupation: Engineer
      ```
   *  `display_profile()` (no arguments) should print "No profile information provided." or similar. -->

***Experiment and test your functions with various calls using different numbers of positional and keyword arguments! üöÄ***

**Next: We are moving on from parameter types to explore a related concept: Inner Functions! ‚û°Ô∏è**

---

### Inner Functions (Functions inside Functions) ‚öôÔ∏è
# Inner Functions: Functions Defined Inside Other Functions

**Python allows you to define functions *inside* other functions. These are called **inner functions** or nested functions.**

**What are Inner Functions?**

*   **Function defined within another function's scope:** An inner function is defined using the `def` keyword *inside* the body of an outer function.
*   **Local scope:**  Inner functions have *local scope* with respect to the outer function.  They are only accessible and callable from within the outer function where they are defined.
*   **Outer function provides enclosing scope:** The outer function encloses the inner function and determines its scope.
---

### Inner Functions (Functions inside Functions) ‚öôÔ∏è
<!-- # Inner Functions: Functions Defined Inside Other Functions

**Python allows you to define functions *inside* other functions. These are called **inner functions** or nested functions.** -->

**Example - Defining and using an inner function:**

```python
def outer_function(outer_param):
    """Outer function demonstrating an inner function."""

    def inner_function(inner_param): # Defined inside outer_function - INNER FUNCTION
        """Inner function - only accessible within outer_function."""
        return f"Inner function called with: {inner_param}, Outer parameter was: {outer_param}"

    print("Inside outer_function, calling inner_function:")
    result_from_inner = inner_function("Inner argument") # Calling inner_function from within outer
    return result_from_inner # Outer function returns what inner function returned


output = outer_function("Outer argument value") # Calling the outer function
print(output) # Output: Inner function called with: Inner argument, Outer parameter was: Outer argument value

# inner_function("Direct call") # This would cause an ERROR! inner_function is not defined in global scope
# NameError: name 'inner_function' is not defined
```
---

### Inner Functions (Functions inside Functions) ‚öôÔ∏è
# Inner Functions: Functions Defined Inside Other Functions

**Python allows you to define functions *inside* other functions. These are called **inner functions** or nested functions.**

**Explanation:**

1. `inner_function` is defined *inside* `outer_function`.
2. `inner_function` can only be called from within `outer_function` (in this example, we call it inside `outer_function` and then return its result).
3. Attempting to call `inner_function` directly from outside `outer_function` will result in a `NameError` because `inner_function`'s scope is limited to `outer_function`.
---

### Inner Functions (Functions inside Functions) ‚öôÔ∏è
# Inner Functions: Functions Defined Inside Other Functions

**Python allows you to define functions *inside* other functions. These are called **inner functions** or nested functions.**

**Why use Inner Functions?**

- **Encapsulation and Organization:** Helps organize code by grouping related functions together logically. Inner functions can be helper functions used only by the outer function, keeping the code within the outer function more self-contained and readable.

- **Closures:** Inner functions are closely related to the concept of closures (we might explore this in more advanced sessions).

**Next: Let's look at another example and understand when inner functions can be useful! ‚û°Ô∏è**

---

### Inner Function Example - Formatting Names ‚öôÔ∏è
# Inner Function Example: Formatting Names
**Let's see a practical example where inner functions can be useful for code organization.**

**Scenario:** You need a function to format names. The formatting involves two steps:

1.  **Cleaning up whitespace:** Remove leading/trailing spaces and extra spaces within the name.
2.  **Capitalization:** Capitalize the first letter of each word in the name.

We can use inner functions to structure this logic clearly.
---

### Inner Function Example - Formatting Names ‚öôÔ∏è
<!-- # Inner Function Example: Formatting Names
**Let's see a practical example where inner functions can be useful for code organization.** -->

**Example - Using inner functions for name formatting:**

```python
def format_name(name_string):
    """Formats a name string by cleaning whitespace and capitalizing words."""

    def cleanup_whitespace(text): # Inner function 1: Handles whitespace cleanup
        """Removes extra whitespace from a string."""
        return " ".join(text.strip().split()) # Strip and then join words with single spaces

    def capitalize_words(text): # Inner function 2: Capitalizes words
        """Capitalizes the first letter of each word in a string."""
        return text.title() # title() method capitalizes first letter of each word

    cleaned_name = cleanup_whitespace(name_string) # Use inner function 1
    formatted_name = capitalize_words(cleaned_name) # Use inner function 2
    return formatted_name # Outer function returns the final formatted name


name1 = format_name("  john  doe  ")
print(f"Formatted name 1: '{name1}'") # Output: Formatted name 1: 'John Doe'

name2 = format_name("pEtEr  rAbBiT")
print(f"Formatted name 2: '{name2}'") # Output: Formatted name 2: 'Peter Rabbit'
```
---

### Inner Function Example - Formatting Names ‚öôÔ∏è
# Inner Function Example: Formatting Names
<br>

**Explanation:**

- format_name is the outer function responsible for the overall name formatting process.
- cleanup_whitespace and capitalize_words are inner functions, each responsible for a specific formatting sub-task.
- format_name calls these inner functions in sequence to achieve the complete formatting.
---

### Inner Function Example - Formatting Names ‚öôÔ∏è
# Inner Function Example: Formatting Names
<br>

**Benefits of using inner functions here:**

- **Organization:** Breaks down the formatting logic into smaller, well-defined, and named steps.
- **Readability:** Makes the `format_name` function easier to read and understand as it clearly outlines the formatting steps.
- **Encapsulation:** `cleanup_whitespace` and `capitalize_words` are helper functions specific to `format_name` and are hidden from the outside, keeping the namespace cleaner.

**Inner functions can be a great way to improve code structure and readability, especially when dealing with functions that perform multi-step processes!**

**Next: Let's briefly touch upon "returning functions from functions" (Higher-Order Functions) - a slightly more advanced function concept! ‚û°Ô∏è**

---

### Returning Functions from Functions (Brief Intro) ‚öôÔ∏è
#  Returning Functions from Functions - Functions as Return Values

**In Python, functions are first-class citizens. This means you can do interesting things with functions, including **returning a function from another function!***

**Functions as Return Values (Higher-Order Functions):**

*   **Functions can produce other functions:**  A function can be designed to *create* and *return* another function as its result.
*   **Outer function acts as a factory:** The outer function can act like a factory that generates specialized inner functions based on some logic or input.
*   **Returned function can then be called later:** The function returned by the outer function can be assigned to a variable and called just like any other function.
---

### Returning Functions from Functions (Brief Intro) ‚öôÔ∏è
#  Returning Functions from Functions - Functions as Return Values

*In Python, functions are first-class citizens. This means you can do interesting things with functions, including **returning a function from another function!***

**Example - Function returning another function:**

```python
def create_multiplier(factor):
    """
    Creates and returns a function that multiplies its input by 'factor'.

    'factor' is captured from the outer function's scope (closure concept).
    """
    def multiplier_function(number): # Inner function: multiplies by 'factor'
        """Multiplies 'number' by the 'factor' from the outer function."""
        return number * factor

    return multiplier_function # Return the inner function itself (not call it yet)
```
---

### Returning Functions from Functions (Brief Intro) ‚öôÔ∏è
#  Returning Functions from Functions - Functions as Return Values

**In Python, functions are first-class citizens. This means you can do interesting things with functions, including **returning a function from another function!***

**Example - Function returning another function:**

```py
multiply_by_5 = create_multiplier(5) # Call create_multiplier() - it RETURNS multiplier_function
multiply_by_10 = create_multiplier(10) # Call again with a different factor

# Now, multiply_by_5 and multiply_by_10 are functions themselves!
result1 = multiply_by_5(3) # Call the *returned* function multiply_by_5
print(result1) # Output: 15 (3 * 5)

result2 = multiply_by_10(7) # Call the *returned* function multiply_by_10
print(result2) # Output: 70 (7 * 10)
```
---

### Returning Functions from Functions (Brief Intro) ‚öôÔ∏è
<!-- #  Returning Functions from Functions - Functions as Return Values

**In Python, functions are first-class citizens. This means you can do interesting things with functions, including **returning a function from another function!*** -->

**Explanation:**

1. `create_multiplier(factor)` is a function that *creates and returns* `multiplier_function`.
2. `multiplier_function` is an inner function that uses the `factor` from the *outer* function's scope (this is related to closures, a slightly more advanced topic).
3. When you call `create_multiplier(5)`, it *returns* the `multiplier_function` that is specialized to multiply by 5. This returned function is then assigned to `multiply_by_5`.
4. Similarly, `create_multiplier(10)` returns a `multiplier_function` specialized to multiply by 10, assigned to `multiply_by_10`.
5. Now, `multiply_by_5` and `multiply_by_10` can be called like regular functions to perform multiplication by their respective factors.

**This concept of functions returning functions is a key aspect of functional programming in Python and is used in more advanced techniques like decorators (which we'll explore later)!**

**Next: Let's summarize Session 5 and wrap up our exploration of Functions! ‚û°Ô∏è**

---

### Session 5 Summary - Functions ‚úÖ
# Session 5 Wrap-up:  Functions - Modularizing Your Code

**Congratulations on completing Session 5: "Functions - Modularizing Your Code"!** üéâ

**In this session, you've learned the fundamental concepts of functions in Python:**

*   **What Functions Are:** Reusable blocks of code, like mini-programs within your program. üöÄ
*   **Why Functions Are Essential:** Code reusability, organization, abstraction, readability, and maintainability.  ‚ú®
*   **Defining Functions (`def` keyword):**  Creating your own functions with names, parameters, and code blocks. ‚úçÔ∏è
*   **Calling Functions:** Executing functions by their name and passing arguments. üìû
*   **Function Parameters & Arguments:**  Passing input data to functions using positional, keyword, and default parameters. üì•üì§

---

### Session 5 Summary - Functions ‚úÖ
# Session 5 Wrap-up:  Functions - Modularizing Your Code

**Congratulations on completing Session 5: "Functions - Modularizing Your Code"!** üéâ

**In this session, you've learned the fundamental concepts of functions in Python:**

*   **`return` Values:**  Getting output and results back from functions. ‚Ü©Ô∏è
*   **Function Scope:** Understanding local and global variables and their accessibility. üåçüè†
*   **Docstrings:**  Documenting your functions for clarity and usability. üìù
*   **`*args` and `**kwargs`:** Creating flexible functions that accept variable numbers of arguments. ‚öôÔ∏è
*   **Inner Functions:** Defining functions inside other functions for better code organization. ‚öôÔ∏è
*   **(Brief Intro) Returning Functions from Functions:**  Understanding functions as first-class citizens and the concept of higher-order functions. ‚öôÔ∏è
---

### Session 5 Summary - Functions ‚úÖ
# Session 5 Wrap-up:  Functions - Modularizing Your Code

**Congratulations on completing Session 5: "Functions - Modularizing Your Code"!** üéâ

**In this session, you've learned the fundamental concepts of functions in Python:**

**Key Takeaway from Session 5:**

*   Functions are a cornerstone of good programming. You are now equipped to write modular, reusable, and well-organized Python code.  By breaking down problems into functions, you can create more complex and manageable programs!  You've significantly leveled up your Python programming skills! üí™

**Next:  That's the end of Session 5! Let's conclude this session officially on the next slide!** ‚û°Ô∏è

---
layout: two-cols-header
---

### Session 5 - Session End üéâ

# Session 5 Complete!  Functions - Modularizing Your Code ‚úÖ

<!-- **You have reached the end of Session 5: "Functions - Modularizing Your Code"!** -->

<!-- **Excellent work!** You've now gained a strong understanding of Python functions, a truly essential concept in programming. -->

::left::

**Key achievements in this session:**

*   You can now define and call your own functions.
*   You understand how to use parameters and arguments to pass data to functions.
*   You know how to get results back from functions using `return` values.
*   You can use `*args` and `**kwargs` for flexible function design.
*   You understand function scope and the difference between local and global variables.
::right::
*   You appreciate the importance of documenting your code with docstrings.
*   You've even had a glimpse into more advanced function concepts like inner functions and returning functions!

**You are now well-equipped to write much more organized, reusable, and efficient Python code!**

**Ready to move on to the next session?**

**Up Next: Session 6 - Working with Files - Input and Output!** üöÄ
