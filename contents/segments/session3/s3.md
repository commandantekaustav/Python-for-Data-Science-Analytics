---
transition: slide-left
align: centre
title: Diving into Core Python - Data Structures!
layout: section
---

## Session 3
# Diving into Core Python - Data Structures! 🗃️
---

## Session 3 - Welcome to Core Py Data Structures! 🚀

**Welcome to Session 3: "Core Python - Beyond the Basics"!** 🎉

In the previous sessions, you've set up your environment and learned about writing clean, stylish Python code.

**Now, it's time to start exploring the *heart* of Python: its core data structures!**

**In this session, we will dive deep into:**

<v-clicks>

*   **Lists:** Ordered, mutable sequences - the workhorse of Python data. 🗂️
*   **Tuples:** Ordered, *immutable* sequences - for fixed collections of items. 📦
*   **Dictionaries:** Key-value pairs - for efficient data lookup and organization. 🔑
*   **Sets:** Unordered collections of unique items - for membership testing and removing duplicates. HashSet
</v-clicks>

**Understanding and effectively using these data structures is fundamental to writing powerful and efficient Python programs.**

**Get ready to expand your Python toolkit and start working with data in Session 3!** 💪

**(Session 3: Core Python - Data Structures - Introduction)**
---
layout: two-cols-header
---

### Introduction to Lists 🗂️
# Core Python Data Structures: Lists - Ordered Collections

**Let's start with the first essential data structure in Python: **Lists**.**

::left::

**What are Lists in Python?**

<v-clicks>

*   **Ordered collections:** Lists store items in a specific sequence. The order of elements is maintained.
*   **Mutable:**  You can change lists after they are created - you can add, remove, or modify elements.
*   **Contain items of different d-types:** A single list can hold integers, strings, floats, even other lists!
*   **Created using square brackets `[]`** and items are separated by commas `,`.
</v-clicks>

::right::

**Why are Lists so important?**
<v-clicks>

*   **Versatile and widely used:** Lists are used everywhere in Python programming for storing and manipulating collections of data.
*   **Foundation for many other data structures and algorithms.**
*   **Essential for working with sequences of items, like lines in a file, words in a sentence, or records in a dataset.**
</v-clicks>

---

### Introduction to Lists 🗂️
# Core Python Data Structures: Lists - Ordered Collections

**In the next few slides, we will explore:**
<v-clicks>

*   **Creating Lists**
*   **Accessing List elements (indexing and slicing)**
*   **Modifying Lists (adding, removing, changing elements)**
*   **List methods (common operations you can perform on lists)**
*   **...and more!**
</v-clicks>

**Get ready to master Python Lists!** 💪

<!-- **(Core Python - Data Structures - Lists)** -->

---
layout: two-cols-header
---

## Creating Lists 🛠️

# Creating Python Lists: Multiple Ways to Start

**Let's learn how to create lists in Python. There are several ways to do this:**

::left::

**1. Creating an Empty List:**

*   You can create an empty list using empty square brackets `[]` or the `list()` constructor with no arguments.

    ```python
    # Method 1: Using square brackets
    my_list = []
    print(my_list)  # Output: []
    print(type(my_list)) # Output: <class 'list'>

    # Method 2: Using the list() constructor
    another_list = list()
    print(another_list) # Output: []
    print(type(another_list)) # Output: <class 'list'>
    ```

::right::

**2. Creating a List with Initial Values:**

*   Enclose comma-separated values within square brackets `[]`.

    ```python
    numbers = [1, 2, 3, 4, 5]
    print(numbers) # Output: [1, 2, 3, 4, 5]

    fruits = ["apple", "banana", "orange"]
    print(fruits) # Output: ['apple', 'banana', 'orange']

    mixed_list = [10, "hello", 3.14, True] # Lists can hold different data types
    print(mixed_list) # Output: [10, 'hello', 3.14, True]
    ```
---
layout: two-cols-header
---

## Creating Lists 🛠️

# Creating Python Lists: Multiple Ways to Start

::left::

**3. Creating a List from Another Sequence (using `list()` constructor):**

*   You can convert other iterable objects (like strings, tuples, ranges) into lists using the `list()` constructor.

    ```python
    string_chars = list("Python") # String converted to list of characters
    print(string_chars) # Output: ['P', 'y', 't', 'h', 'o', 'n']

    number_range = list(range(5)) # range() converted to a list of numbers
    print(number_range) # Output: [0, 1, 2, 3, 4]
    ```

::right::

**Your Turn!**

*   In your Jupyter Notebook, try creating lists using all three methods above.
*   Create a list of your favorite colors, a list of numbers, and a list from a string.
*   Print your lists and check their types to confirm they are lists!

**Next: Let's learn how to access elements within a list!** ➡️

---
layout: two-cols-header
---

## Accessing List Elements (Indexing) 📍

# Accessing List Elements: Indexing

**Once you have a list, you need to be able to access the individual items stored in it.  We do this using **indexing**.**

::left::

**List Indexing Basics:**
<v-clicks>

*   **Each element in a list has a position, called its **index**.**
*   **Python lists are **zero-indexed**, meaning the first element is at index `0`, the second at index `1`, and so on.**
*   **You can access an element by using its index in square brackets `[]` after the list name.**
</v-clicks>

::right::

**Positive Indexing (starting from the beginning):**

```python
my_list = ['a', 'b', 'c', 'd', 'e']

print(my_list[0])  # Output: 'a' (first element, index 0)
print(my_list[1])  # Output: 'b' (second element, index 1)
print(my_list[3])  # Output: 'd' (fourth element, index 3)
```

---

## Accessing List Elements (Indexing) 📍

# Accessing List Elements: Indexing

**Negative Indexing (starting from the end):**
- You can also access elements from the end of the list using negative indices.
- `-1` refers to the last element, `-2` to the second-to-last, and so on.

```py
print(my_list[-1]) # Output: 'e' (last element)
print(my_list[-2]) # Output: 'd' (second-to-last element)
print(my_list[-5]) # Output: 'a' (first element, also index 0)
```

**Important: Index out of range!**
- If you try to access an index that is outside the valid range of indices for the list (e.g., index greater than or equal to the list length, or index less than negative list length), you will get an `IndexError`.

```py
# print(my_list[5])  # This will cause an IndexError: list index out of range
```
---

## Accessing List Elements (Indexing) 📍

# Accessing List Elements: Indexing
<br>

**Your Turn!**
- Create a list of your favorite fruits.
- Use indexing to print:
    - The first fruit in your list.
    - The third fruit in your list.
    - The last fruit in your list (using negative indexing).
    - Try to access an index that is out of range (e.g., index 10 if your list has fewer than 10 items) and see the IndexError.

**Next: Let's explore another way to access list elements: Slicing! ➡️**
---

### Accessing List Elements (Slicing) 🔪
# Accessing List Elements: Slicing

**Slicing allows you to extract a *portion* or a *sub-list* from a list, not just single elements.**

**List Slicing Basics:**

*   You use a colon `:` inside square brackets `[]` to specify a slice.
*   The basic slice syntax is `[start:stop:step]`.
*   **`start` (optional):**  The index to start the slice from (inclusive). If omitted, defaults to `0` (beginning of the list).
*   **`stop` (optional):** The index to stop the slice *before* (exclusive). If omitted, defaults to the end of the list.
*   **`step` (optional):**  The increment between indices. If omitted, defaults to `1`.

---

### Accessing List Elements (Slicing) 🔪
# Accessing List Elements: Slicing

**Examples of List Slicing:**

```python
my_list = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

print(my_list[1:4])    # Output: ['b', 'c', 'd'] (elements from index 1 up to, but not including, index 4)
print(my_list[0:3])    # Output: ['a', 'b', 'c'] (first three elements)
print(my_list[:3])     # Output: ['a', 'b', 'c'] (start defaults to 0)
print(my_list[4:])     # Output: ['e', 'f', 'g', 'h'] (stop defaults to end)

# Output: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] (start and stop defaults - creates a copy of the whole list)
print(my_list[:])      

print(my_list[1:7:2])  # Output: ['b', 'd', 'f'] (elements from index 1 to 7, taking every 2nd element)
print(my_list[::2])   # Output: ['a', 'c', 'e', 'g'] (every 2nd element from the beginning)
print(my_list[::-1])  # Output: ['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a'] (reverse the list using step -1)
```
---

### Accessing List Elements (Slicing) 🔪
# Accessing List Elements: Slicing

**Your Turn!**

- Using your list of fruits from the previous exercise (or create a new longer list).
- Try these slicing operations:
    - Get the first two fruits.
    - Get fruits from the 2nd fruit to the 4th fruit.
    - Get the last three fruits (using negative indexing in slicing).
    - Try slicing with a step of 2 or 3.
    - Reverse your list using slicing.

**Slicing is a powerful way to work with portions of lists in Python!** ✨

**Next: Let's learn how to modify lists - adding, removing, and changing elements!** ➡️
---
layout: two-cols-header
---

## Modifying Lists (Mutability) 🛠️
# Modifying Lists: Lists are Mutable!

**One of the key features of lists is that they are **mutable**, which means you can change their contents *after* they are created.**

**Common List Modification Operations:**

1.  **Changing Element Value (Assignment):**
    *   You can change the value of an element at a specific index by assigning a new value to it using indexing.

    ```python
    fruits = ["apple", "banana", "cherry"]
    print(fruits) # Output: ['apple', 'banana', 'cherry']

    fruits[1] = "grape" # Change the element at index 1 (banana -> grape)
    print(fruits) # Output: ['apple', 'grape', 'cherry']
    ```
---

## Modifying Lists (Mutability) 🛠️
# Modifying Lists: Lists are Mutable!

**One of the key features of lists is that they are **mutable**, which means you can change their contents *after* they are created.**

**Common List Modification Operations:**

2.  **Adding Elements:**
    *   **`append(item)`:** Adds an item to the *end* of the list.
    *   **`insert(index, item)`:** Inserts an item at a *specific index*.

    ```python
    numbers = [1, 2, 3]
    numbers.append(4) # Add 4 to the end
    print(numbers) # Output: [1, 2, 3, 4]

    numbers.insert(0, 0) # Insert 0 at the beginning (index 0)
    print(numbers) # Output: [0, 1, 2, 3, 4]
    ```
---
layout: two-cols-header
---

## Modifying Lists (Mutability) 🛠️
# Modifying Lists: Lists are Mutable!

**One of the key features of lists is that they are **mutable**, which means you can change their contents *after* they are created.**

**Common List Modification Operations:**
::left::
3.  **Removing Elements:**
    *   **`remove(item)`:** Removes the *first occurrence* of a specific *value* from the list.  Raises a `ValueError` if the item is not found.
    *   **`pop(index)`:** Removes and *returns* the element at a *specific index*. If `index` is not provided, it removes and returns the *last* element.
    *   **`clear()`:** Removes *all* elements from the list, making it empty.
::right::

```python
colors = ["red", "green", "blue", "green"]
colors.remove("green") # Removes the first "green"
print(colors) # Output: ['red', 'blue', 'green']

# Remove and return element at index 1 ('blue')
removed_color = colors.pop(1) 

print(colors) # Output: ['red', 'green']
print(removed_color) # Output: blue

colors.clear() # Remove all elements
print(colors) # Output: []
```

---

## Modifying Lists (Mutability) 🛠️
# Modifying Lists: Lists are Mutable!

**One of the key features of lists is that they are **mutable**, which means you can change their contents *after* they are created.**

**Your Turn!**

*   Start with a list of numbers or fruits.
*   Try:
    *   Changing an element at a specific index.
    *   Adding elements using `append()` and `insert()`.
    *   Removing elements using `remove()`, `pop()`, and `clear()`.
*   Print the list after each modification to see the changes!

**Next: Let's explore more useful List Methods (functions that operate on lists)!** ➡️

---
layout: two-cols-header
---

### More Useful List Methods ➕

# Even More List Power: Useful List Methods

**Python lists come with a rich set of built-in methods (functions that are called on list objects) that provide powerful operations.**

**Let's explore some more essential list methods:**
::left::
*   **`len(list)`:**  Returns the **number of elements** in the list (the length of the list). Not a method *called on* the list, but a built-in function *taking* a list as argument.

    ```python
    my_list = [10, 20, 30, 40]
    list_length = len(my_list)
    print(list_length) # Output: 4
    ```
::right::

*   **`list.count(item)`:** Returns the **number of times** a specific `item` appears in the list.

    ```python
    numbers = [1, 2, 2, 3, 2, 4, 2]
    count_of_2 = numbers.count(2)
    print(count_of_2) # Output: 4 (2 appears 4 times)
    ```
---

### More Useful List Methods ➕

# Even More List Power: Useful List Methods
**Let's explore some more essential list methods:**

*   **`list.index(item)`:** Returns the **index of the first occurrence** of a specific `item` in the list.  Raises a `ValueError` if the item is not found.

    ```python
    letters = ['a', 'b', 'c', 'b', 'd']
    index_of_b = letters.index('b') # Returns index of the *first* 'b'
    print(index_of_b) # Output: 1
    ```

*   **`list.sort()`:** Sorts the list **in place** (modifies the original list) in ascending order (by default). You can also sort in descending order and specify custom sorting logic.

    ```python
    numbers = [3, 1, 4, 1, 5, 9, 2, 6]
    numbers.sort() # Sorts in ascending order
    print(numbers) # Output: [1, 1, 2, 3, 4, 5, 6, 9]

    fruits = ["banana", "apple", "orange"]
    fruits.sort() # Sorts strings alphabetically
    print(fruits) # Output: ['apple', 'banana', 'orange']
    ```
---

### More Useful List Methods ➕

# Even More List Power: Useful List Methods
**Let's explore some more essential list methods:**

*   **`list.reverse()`:** Reverses the elements of the list **in place** (modifies the original list).

    ```python
    letters = ['a', 'b', 'c', 'd']
    letters.reverse()
    print(letters) # Output: ['d', 'c', 'b', 'a']
    ```

*   **`list.extend(another_list)`:** Appends all the items from `another_list` to the *end* of the original list (extends the list).

    ```python
    list1 = [1, 2, 3]
    list2 = [4, 5, 6]
    list1.extend(list2) # Extends list1 with elements of list2
    print(list1) # Output: [1, 2, 3, 4, 5, 6]
    ```
---

### More Useful List Methods ➕

# Even More List Power: Useful List Methods

**Your Turn!**

*   Create a list of mixed data types (numbers, strings) and use the following methods:
    *   `len()` to find its length.
    *   `count()` to count occurrences of a specific item.
    *   `index()` to find the index of an item.
    *   `sort()` to sort it (consider what happens with mixed types - you might want to use lists of only numbers or only strings for sorting initially).
    *   `reverse()` to reverse it.
    *   `extend()` to add elements from another list to it.

**These methods greatly enhance your ability to work with and manipulate lists efficiently!** ✨

**Next:  Let's move on to the next core data structure: Tuples!** ➡️
---

## Introduction to Tuples 📦
# Core Python Data Structures: Tuples - Immutable Sequences

**Let's move on to another fundamental sequence type in Python: **Tuples**.**

**What are Tuples in Python?**
<v-clicks>

*   **Ordered collections:** Like lists, tuples store items in a specific sequence.
*   **Immutable:**  **This is the key difference from lists!**  Once a tuple is created, you **cannot change its contents** - you cannot add, remove, or modify elements.  Tuples are fixed.
*   **Contain items of different data types:**  Similar to lists, tuples can hold items of various types.
*   **Created using parentheses `()`** and items are separated by commas `,`.
</v-clicks>

---

## Introduction to Tuples 📦
# Core Python Data Structures: Tuples - Immutable Sequences

**Why use Tuples?  Immutability and More:**

<v-clicks>

*   **Data Integrity:** Immutability ensures that the data in a tuple remains constant throughout your program. This can be important for representing fixed collections of items that should not be accidentally modified.
*   **Performance:** Tuples can be slightly more memory-efficient and faster than lists in some cases, especially when you know the collection will not change.
*   **Representing Fixed Data:** Tuples are often used to represent fixed records of information, like coordinates (x, y), RGB color values (red, green, blue), or database records.
*   **Keys in Dictionaries:**  Tuples can be used as keys in dictionaries (which we'll learn about next!), while lists cannot (because dictionary keys must be immutable).
*   **Returning Multiple Values from Functions:** Functions can efficiently return multiple values as a tuple.
</v-clicks>
---

## Introduction to Tuples 📦
# Core Python Data Structures: Tuples - Immutable Sequences

**In the next few slides, we will explore:**

*   **Creating Tuples**
*   **Accessing Tuple elements (indexing and slicing) - same as lists!**
*   **Tuple methods (fewer than lists, due to immutability)**
*   **Tuple packing and unpacking**
*   **...and more!**

**Get ready to understand the power of immutability with Python Tuples!** 💪

<!-- **(Session 3: Core Python - Data Structures - Tuples)** -->
---

## Creating Tuples 🛠️
# Creating Python Tuples:  Immutable Collections

**Let's learn how to create tuples in Python.  Like lists, there are a few ways to create them:**

**1. Creating a Tuple with Parentheses `()`:**

*   The most common way to create a tuple is by enclosing comma-separated values within parentheses `()`.

    ```python
    # Creating a tuple of numbers
    my_tuple = (10, 20, 30, 40)
    print(my_tuple)  # Output: (10, 20, 30, 40)
    print(type(my_tuple)) # Output: <class 'tuple'>

    # Creating a tuple of strings
    colors = ("red", "green", "blue")
    print(colors) # Output: ('red', 'green', 'blue')

    # Tuple with mixed data types
    mixed_tuple = (1, "hello", 2.5, False)
    print(mixed_tuple) # Output: (1, 'hello', 2.5, False)
    ```
---

## Creating Tuples 🛠️
# Creating Python Tuples:  Immutable Collections

**2. Tuple Packing (without parentheses - often implied):**

*   You can create a tuple simply by separating values with commas, even without parentheses. This is called "tuple packing."

    ```python
    point = 10, 20 # Parentheses are optional here! - Tuple packing
    print(point) # Output: (10, 20)
    print(type(point)) # Output: <class 'tuple'>

    data = "John", 30, "Engineer" # Another example of tuple packing
    print(data) # Output: ('John', 30, 'Engineer')
    ```
---

## Creating Tuples 🛠️
# Creating Python Tuples:  Immutable Collections

**3. Creating a Tuple from Another Sequence (using `tuple()` constructor):**

*   Similar to lists, you can convert other iterable objects (lists, strings, ranges) to tuples using the `tuple()` constructor.

    ```python
    list_to_tuple = tuple([1, 2, 3]) # Convert a list to a tuple
    print(list_to_tuple) # Output: (1, 2, 3)

    string_to_tuple = tuple("tuple") # Convert a string to a tuple of characters
    print(string_to_tuple) # Output: ('t', 'u', 'p', 'l', 'e')
    ```
---

## Creating Tuples 🛠️
# Creating Python Tuples:  Immutable Collections

**4. Creating a Tuple with a Single Element (Important!):**

*   To create a tuple with just *one* element, you **must include a trailing comma** after the element, inside the parentheses.  Otherwise, Python will interpret it as just the value itself, not a tuple.

    ```python
    single_item_tuple = (42,) # Trailing comma is essential!
    print(single_item_tuple) # Output: (42,)
    print(type(single_item_tuple)) # Output: <class 'tuple'>

    not_a_tuple = (42) # No trailing comma - just an integer!
    print(not_a_tuple) # Output: 42
    print(type(not_a_tuple)) # Output: <class 'int'>
    ```
---

## Creating Tuples 🛠️
# Creating Python Tuples:  Immutable Collections
<br>

**Your Turn!**

*   In your Jupyter Notebook, create tuples using all these methods.
*   Experiment with creating empty tuples, tuples with initial values, tuples from strings and lists, and *especially* single-element tuples (remember the comma!).
*   Print your tuples and check their types.

**Next: Let's access elements in tuples using indexing and slicing - just like lists!** ➡️
---
layout: two-cols-header
---

## Accessing Tuple Elements (Indexing & Slicing) 📍🔪
# Accessing Tuple Elements: Indexing and Slicing (Just Like Lists!)

**Good news! Accessing elements in tuples using **indexing** and **slicing** works **exactly the same** way as it does for lists!**
::left::
**Tuple Indexing - Same as Lists (Zero-based indexing):**

```python
my_tuple = ('x', 'y', 'z', 'w')

# Output: 'x' (first element, index 0)
print(my_tuple[0])  

# Output: 'z' (third element, index 2)
print(my_tuple[2])  

# Output: 'w' (last element, negative indexing)
print(my_tuple[-1]) 
```
::right::
**Tuple Slicing - Same as Lists (start:stop:step syntax):**

```py
my_tuple = ('p', 'q', 'r', 's', 't', 'u')

# Output: ('q', 'r', 's') (slice from index 1 to 4)
print(my_tuple[1:4])
# Output: ('p', 'q', 'r') (first three elements)
print(my_tuple[:3])
# Output: ('r', 's', 't', 'u') (from index 2 to the end)     
print(my_tuple[2:])
# Output: ('p', 'r', 't') (every second element)     
print(my_tuple[::2])    
# Output: ('u', 't', 's', 'r', 'q', 'p') (reversed tuple)
print(my_tuple[::-1])   
```
---

## Accessing Tuple Elements (Indexing & Slicing) 📍🔪
# Accessing Tuple Elements: Indexing and Slicing (Just Like Lists!)
<br>

**Important: Immutability and Indexing/Slicing**
- Indexing and slicing do not modify the original tuple. They return new tuples or individual elements.

- You can access elements using indices and slices, but you cannot assign new values to tuple elements using indexing because tuples are immutable.
```py
# my_tuple[0] = 'A'  # This will cause a TypeError: 'tuple' object does not support item assignment
```
---

## Accessing Tuple Elements (Indexing & Slicing) 📍🔪
# Accessing Tuple Elements: Indexing and Slicing (Just Like Lists!)

**Your Turn!**

- Create a tuple of numbers or letters.
- Practice:
    - Accessing individual elements using positive and negative indices.
    - Extracting sub-tuples using slicing with different `start`, `stop`, and `step` values.
    - Try to assign a new value to a tuple element using indexing - observe the `TypeError`.

**Key Takeaway:** Indexing and slicing for tuples work just like lists. Remember that tuples are immutable, so you can't modify them in place using indexing or slicing assignment.

**Next: Let's explore the methods available for tuples - they are fewer than list methods due to immutability!** ➡️
---

## Tuple Methods (Limited, but Useful) 🤏
# Tuple Methods: Fewer Than Lists (Immutability!)

**Because tuples are *immutable* (cannot be changed), they have fewer built-in methods compared to lists.**  You won't find methods to add, remove, or modify elements in tuples.

**However, tuples do have some useful methods:**

*   **`tuple.count(item)`:**  Just like lists, this method returns the **number of times** a specific `item` appears in the tuple.

    ```python
    my_tuple = (1, 2, 2, 3, 2, 4, 2)
    count_of_2 = my_tuple.count(2)
    print(count_of_2) # Output: 4
    ```

*   **`tuple.index(item)`:**  Also like lists, this method returns the **index of the first occurrence** of a specific `item` in the tuple. Raises a `ValueError` if the item is not found.

    ```python
    letters_tuple = ('a', 'b', 'c', 'b', 'd')
    index_of_b = letters_tuple.index('b') # Index of the first 'b'
    print(index_of_b) # Output: 1
    ```
---

## Tuple Methods (Limited, but Useful) 🤏
# Tuple Methods: Fewer Than Lists (Immutability!)
<br>

**Methods NOT available for tuples (due to immutability):**

*   `append()`, `insert()`, `remove()`, `pop()`, `clear()`, `sort()`, `reverse()`, `extend()` -  *all methods that would modify the tuple in-place are NOT available.*

**Why limited methods? Immutability is the reason!**

*   The purpose of tuples is to represent fixed collections of data.  Providing methods to change them would violate this core principle of immutability.

**Example: Trying to use a list method on a tuple (will cause an error):**

```python
my_tuple = (1, 2, 3)
# my_tuple.append(4) # This will cause an AttributeError: 'tuple' object has no attribute 'append'
```
---

## Tuple Methods (Limited, but Useful) 🤏
# Tuple Methods: Fewer Than Lists (Immutability!)
<br>

**Key Takeaway:** Tuples are designed for immutability. They have fewer methods than lists because they cannot be modified after creation.  Use `count()` and `index()` for searching within tuples.  Choose lists when you need mutable sequences, and tuples when you need immutable ones.

**Next: Let's explore a very useful and Pythonic feature related to tuples: Tuple Packing and Unpacking!** ➡️
---

## Tuple Packing and Unpacking 🎁
# Tuple Packing and Unpacking: Pythonic Convenience

**Python offers elegant features called "tuple packing" and "tuple unpacking" that make working with tuples concise and readable.**

**1. Tuple Packing (Creating a tuple implicitly):**

*   We've already seen tuple packing briefly. It's the ability to create a tuple simply by placing comma-separated values on the right-hand side of an assignment, without explicit parentheses (though parentheses are often used for clarity).

    ```python
    # Tuple packing - creating a tuple without parentheses (parentheses optional)
    my_tuple = 10, 20, "hello"
    print(my_tuple) # Output: (10, 20, 'hello')
    ```
---

## Tuple Packing and Unpacking 🎁
# Tuple Packing and Unpacking: Pythonic Convenience

**Python offers elegant features called "tuple packing" and "tuple unpacking" that make working with tuples concise and readable.**


**2. Tuple Unpacking (Assigning tuple elements to variables):**

*   Tuple unpacking is the reverse process. It allows you to extract the individual values from a tuple and assign them to separate variables in a single line of code.
*   The number of variables on the left-hand side must match the number of elements in the tuple.

    ```python
    point = (5, 10) # A tuple representing a point (x, y)

    # Tuple unpacking - assign tuple elements to variables x and y
    x, y = point

    print(x) # Output: 5
    print(y) # Output: 10
    ```
---

## Tuple Packing and Unpacking 🎁
# Tuple Packing and Unpacking: Pythonic Convenience

**Python offers elegant features called "tuple packing" and "tuple unpacking" that make working with tuples concise and readable.**


**More Tuple Unpacking Examples:**

```python
data = ("Alice", 25, "Data Scientist")

name, age, profession = data # Unpack tuple elements to name, age, profession

print(f"Name: {name}, Age: {age}, Profession: {profession}")
# Output: Name: Alice, Age: 25, Profession: Data Scientist
```
---

## Tuple Packing and Unpacking 🎁
# Tuple Packing and Unpacking: Pythonic Convenience

**Why Tuple Packing and Unpacking are Useful:**

- **Readability:** Makes code cleaner and more concise, especially when dealing with multiple values.

- **Swapping Variables:**  You can swap the values of two variables elegantly using tuple packing and unpacking:
```py
a = 10
b = 20
a, b = b, a  # Swap values of a and b in one line! (Tuple packing and unpacking)
print(f"a: {a}, b: {b}") # Output: a: 20, b: 10
```

- **Returning Multiple Values from Functions:** Functions can return multiple values as a tuple, which can then be easily unpacked when calling the function.
---

## Tuple Packing and Unpacking 🎁
# Tuple Packing and Unpacking: Pythonic Convenience

**Your Turn!**
- Create a tuple representing a person's name, age, and city.
- Unpack this tuple into three separate variables: `name`, `age`, `city`.
- Print the variables to verify unpacking worked correctly.
- Try swapping the values of two variables using tuple packing/unpacking.

**Tuple packing and unpacking are powerful and Pythonic ways to work with tuples efficiently!** ✨

**Next: Let's move on to the next essential data structure: Dictionaries!** ➡️
---

## Introduction to Dictionaries 🔑
# Core Py Data Structures: Dictionaries - Key-Val Pairs

**Now, let's explore another incredibly important and versatile data structure in Python: **Dictionaries**.**

**What are Dictionaries in Python?**

*   **Unordered collections of key-value pairs:** Dictionaries store data as pairs of **keys** and their associated **values**.
*   **Keys are unique and immutable:**  Keys must be unique within a dictionary and must be of immutable types (like strings, numbers, tuples).  Lists cannot be used as keys because they are mutable.
*   **Values can be of any data type:**  Values associated with keys can be of any Python data type (numbers, strings, lists, tuples, even other dictionaries!).
*   **Dictionaries are also mutable:** You can add, remove, modify key-val pairs after the dictionary is created.
*   **Created using curly braces `{}`** and key-value pairs are separated by commas `,`.  Within each pair, the key and value are separated by a colon `:`.
---
layout: two-cols-header
---

### Introduction to Dictionaries 🔑
# Core Py Data Structures: Dictionaries - Key-Val Pairs <br>
### **Why are Dictionaries so important?**

::left:: 
*   **Efficient Data Lookup:** Dictionaries are designed for very fast retrieval of values based on their keys.  Looking up a value by its key is extremely quick, even in large dictionaries.
*   **Representing Mappings and Relationships:** Dictionaries are ideal for representing mappings between things, like:
    *   Words and their definitions
    *   Usernames and user profiles
    *   Product IDs and product details
    *   Configuration settings

::right::

*   **Organizing and Structuring Data:**  It provides a flexible way to structure and organize complex data in a human-readable and easily accessible format.

**In the next few slides, we will explore:**
*   **Creating Dictionaries**
*   **Accessing Dictionary values using keys**
*   **Modifying Dictionaries**
  <!-- (adding, removing, changing key-value pairs)** -->
*   **Dictionary methods (common operations)**
*   **...and more!**

**Get ready to unlock the power of key-value pairs with Python Dictionaries!** 💪

<!-- **(Session 3: Core Python - Data Structures - Dictionaries)** -->
---

### Creating Dictionaries 🛠️

# Creating Python Dictionaries: Key-Value Pairs

<!-- **Let's learn how to create dictionaries in Python.** -->
  <!-- Here are common ways to create dictionaries:** -->

**1. Creating a Dictionary with Curly Braces `{}` and Key-Value Pairs:**

*   The most common method is to use curly braces `{}` and define key-value pairs directly.  Each pair is in the format `key: value`, and pairs are separated by commas.

    ```python
    student = {
        "name": "Alice",
        "age": 20,
        "major": "Computer Science"
    }
    print(student)  # Output: {'name': 'Alice', 'age': 20, 'major': 'Computer Science'}
    print(type(student)) # Output: <class 'dict'>

    squares = {1: 1, 2: 4, 3: 9, 4: 16} # Dictionary with numbers as keys and values

    print(squares) # Output: {1: 1, 2: 4, 3: 9, 4: 16}

    empty_dict = {} # Empty dictionary
    print(empty_dict) # Output: {}
    ```
---

### Creating Dictionaries 🛠️

# Creating Python Dictionaries: Key-Value Pairs

<!-- **Let's learn how to create dictionaries in Python.** -->
  <!-- Here are common ways to create dictionaries:** -->

**2. Using the `dict()` Constructor:**

*   You can use the `dict()` constructor in several ways to create dictionaries:

    *   **From keyword arguments:**  Keys are given as keywords, and values are assigned using `=`. Keys become strings automatically.

        ```python
        person = dict(name="Bob", city="New York", job="Engineer") # Keys as keywords
        print(person) # Output: {'name': 'Bob', 'city': 'New York', 'job': 'Engineer'}
        ```

    *   **From a list of tuples (key-value pairs):** Each tuple in the list represents a key-value pair.

        ```python
        pairs = [("fruit", "apple"), ("color", "red"), ("price", 1.0)]
        fruit_dict = dict(pairs) # List of tuples to dictionary
        print(fruit_dict) # Output: {'fruit': 'apple', 'color': 'red', 'price': 1.0}
        ```
---
layout: two-cols-header
---

### Creating Dictionaries 🛠️

# Creating Python Dictionaries: Key-Value Pairs

<!-- **Let's learn how to create dictionaries in Python.** -->
  <!-- Here are common ways to create dictionaries:** --> <br>

::left::
**Important Notes on Dictionary Keys:**

*   Keys must be **immutable** types: strings, numbers, tuples are commonly used as keys. Lists are NOT allowed as keys because they are mutable.
*   Keys must be **unique** within a dictionary. If you use the same key multiple times, the last value assigned to that key will be kept.

**Your Turn!**

*   In your Jupyter Notebook, create dictionaries using both methods shown above.
::right::
*   Create a dictionary to store information about a book (title, author, publication year).
*   Create a dictionary mapping numbers to their squares (like the `squares` example).
*   Experiment with using different data types as keys and values.
*   Try to create a dictionary with duplicate keys - observe what happens.

**Next: Let's learn how to access values in dictionaries using their keys!** ➡️
---

### Accessing Dictionary Values 🔑
# Accessing Dictionary Values: Using Keys

**The primary way to retrieve information from a dictionary is by using its **keys**.**

**Accessing Values using Square Brackets `[]`:**

*   You access the value associated with a key by placing the key inside square brackets `[]` after the dictionary name, similar to list indexing but using keys instead of numerical indices.

    ```python
    student = {
        "name": "Alice",
        "age": 20,
        "major": "Computer Science"
    }

    print(student["name"])  # Output: 'Alice' (value associated with key "name")
    print(student["major"]) # Output: 'Computer Science' (value for key "major")
    ```
---

### Accessing Dictionary Values 🔑
# Accessing Dictionary Values: Using Keys

**Important: KeyError if Key Not Found!**

*   If you try to access a key that **does not exist** in the dictionary, Python will raise a `KeyError`.

    ```python
    # print(student["city"]) # This will cause a KeyError: 'city' - because "city" key is not in the dictionary
    ```
---
layout: two-cols-header
---

### Accessing Dictionary Values 🔑
# Accessing Dictionary Values: Using Keys

::left::

**Using the `get()` Method - Safer Value Access:**

*   The `get(key, default_value)` method provides a safer way to access dictionary values.
*   If the `key` exists in the dictionary, `get()` returns its corresponding value.
*   If the `key` **does not exist**, `get()` returns the `default_value` you provide (or `None` if you don't provide a `default_value`).  It **does not raise a `KeyError`**.

::right::

```python
student = {
    "name": "Alice",
    "age": 20,
    "major": "Computer Science"
}

city = student.get("city") # Key "city" does not exist
print(city) 
# Output: None (default return value when key is not found)

city_with_default = student.get("city", "Unknown City") 
# Default value "Unknown City"

print(city_with_default) # Output: 'Unknown City'

name = student.get("name") # Key "name" exists
print(name) # Output: 'Alice'
```

---

### Accessing Dictionary Values 🔑
# Accessing Dictionary Values: Using Keys

**Your Turn!**

*   Using your "book" dictionary from the previous exercise (or create a new dictionary).
*   Practice:

    *   Accessing values using square bracket notation `[]` for existing keys.
    *   Trying to access a value using square brackets `[]` for a non-existent key - observe the `KeyError`.
    *   Using the `get()` method to access values for both existing and non-existent keys, with and without providing a `default_value`.

**Key Takeaway:** Use square bracket `[]` notation for direct value access when you are sure the key exists. Use the `get()` method for safer access, especially when you are not certain if a key is present in the dictionary, and want to avoid `KeyError` exceptions.

**Next: Let's learn how to modify dictionaries - adding, updating, and removing key-value pairs!** ➡️

---

### Modifying Dictionaries (Mutability) 🛠️

# Modifying Dictionaries: Dictionaries are Mutable!

**Dictionaries, like lists, are **mutable**, meaning you can change their contents after creation. You can add, update, and remove key-value pairs.**

**Common Dictionary Modification Operations:**

1.  **Adding New Key-Value Pairs:**
    *   Simply assign a value to a new key using square bracket notation `[]`. If the key doesn't exist, it will be added to the dictionary.

    ```python
    student = {"name": "Alice", "age": 20}
    print(student) # Output: {'name': 'Alice', 'age': 20}

    student["city"] = "London" # Add a new key-value pair: "city": "London"
    print(student) # Output: {'name': 'Alice', 'age': 20, 'city': 'London'}
    ```
---

### Modifying Dictionaries (Mutability) 🛠️

# Modifying Dictionaries: Dictionaries are Mutable!

**Dictionaries, like lists, are **mutable**, meaning you can change their contents after creation. You can add, update, and remove key-value pairs.**

2.  **Updating Existing Values:**
    *   To change the value associated with an existing key, use the same square bracket assignment. If the key already exists, its value will be updated.

    ```python
    student = {"name": "Alice", "age": 20, "city": "London"}
    print(student) # Output: {'name': 'Alice', 'age': 20, 'city': 'London'}

    student["age"] = 21 # Update the value for the key "age"
    print(student) # Output: {'name': 'Alice', 'age': 21, 'city': 'London'}
    ```
---

### Modifying Dictionaries (Mutability) 🛠️

# Modifying Dictionaries: Dictionaries are Mutable!

**Dictionaries, like lists, are **mutable**, meaning you can change their contents after creation. You can add, update, and remove key-value pairs.**

3.  **Removing Key-Value Pairs:**
    *   **`del dictionary[key]`:**  Deletes the key-value pair associated with the specified `key`.  Raises a `KeyError` if the key does not exist.

    ```python
    student = {"name": "Alice", "age": 21, "city": "London", "major": "Computer Science"}
    print(student) # Output: {'name': 'Alice', 'age': 21, 'city': 'London', 'major': 'Computer Science'}

    del student["city"] # Remove the key "city" and its value
    print(student) # Output: {'name': 'Alice', 'age': 21, 'major': 'Computer Science'}

    # del student["gpa"] # This would cause a KeyError if "gpa" is not in the dictionary
    ```
---

### Modifying Dictionaries (Mutability) 🛠️

# Modifying Dictionaries: Dictionaries are Mutable!

**Dictionaries, like lists, are **mutable**, meaning you can change their contents after creation. You can add, update, and remove key-value pairs.**

3.  **Removing Key-Value Pairs (cntd.):**

    *   **`dictionary.pop(key, default_value)`:** Removes and *returns* the value associated with `key`.  If `key` is not found, it returns `default_value` (if provided) or raises a `KeyError` (if `default_value` is not provided).

    ```python
    student = {"name": "Alice", "age": 21, "major": "Computer Science"}
    major = student.pop("major") # Remove and return the value for "major"
    print(student) # Output: {'name': 'Alice', 'age': 21}
    print(major) # Output: 'Computer Science'

    # city = student.pop("city") # This would cause a KeyError if "city" is not in the dictionary
    city_default = student.pop("city", "Not found") # No KeyError, returns default
    print(city_default) # Output: Not found
    ```
---

### Modifying Dictionaries (Mutability) 🛠️
# Modifying Dictionaries: Dictionaries are Mutable!

**Dictionaries, like lists, are **mutable**, meaning you can change their contents after creation. You can add, update, and remove key-value pairs.**

3.  **Removing Key-Value Pairs (cntd.):**

    *   **`dictionary.clear()`:** Removes all key-value pairs from the dictionary, making it empty.

    ```python
    student = {"name": "Alice", "age": 21}
    student.clear() # Remove all key-value pairs
    print(student) # Output: {}
    ```
---

### Modifying Dictionaries (Mutability) 🛠️
# Modifying Dictionaries: Dictionaries are Mutable!
<br>

**Your Turn!**

*   Start with your "book" dictionary or create a new dictionary.
*   Practice:
    *   Adding new key-value pairs.
    *   Updating values for existing keys.
    *   Removing key-value pairs using `del` and `pop()`.
    *   Clearing the entire dictionary using `clear()`.
*   Print the dictionary after each modification to observe the changes.

**Next: Let's explore some more useful Dictionary Methods!** ➡️

---

### More Useful Dictionary Methods ➕
# Unlock More Dictionary Power: Essential Methods

**Python dictionaries come with a set of powerful built-in methods for common operations.** Let's explore some of the most useful ones:

*   **`dictionary.keys()`:** Returns a *view object* that displays a list of all **keys** in the dictionary.  This view object is dynamic - it reflects changes to the dictionary.

    ```python
    student = {"name": "Alice", "age": 21, "major": "Computer Science"}
    keys_view = student.keys()
    print(keys_view) # Output: dict_keys(['name', 'age', 'major'])

    # Keys view object reflects changes in the dictionary
    student["city"] = "New York"
    print(keys_view) # Output: dict_keys(['name', 'age', 'major', 'city'])
    ```
---

### More Useful Dictionary Methods ➕
# Unlock More Dictionary Power: Essential Methods

*   **`dictionary.values()`:** Returns a *view object* that displays a list of all **values** in the dictionary.  Also dynamic and reflects changes.

    ```python
    student = {"name": "Alice", "age": 21, "major": "Computer Science"}
    values_view = student.values()
    print(values_view) # Output: dict_values(['Alice', '21', 'Computer Science'])

    student["age"] = 22 # Update a value
    print(values_view) # Output: dict_values(['Alice', '22', 'Computer Science'])
    ```
---

### More Useful Dictionary Methods ➕
# Unlock More Dictionary Power: Essential Methods

*   **`dictionary.items()`:** Returns a *view object* that displays a list of all **key-value pairs** in the dictionary as tuples. Dynamic and reflects changes.

    ```python
    student = {"name": "Alice", "age": 21, "major": "Computer Science"}
    items_view = student.items()
    print(items_view) # Output: dict_items([('name', 'Alice'), ('age', 21), ('major', 'Computer Science')])

    del student["major"] # Remove a key-value pair
    print(items_view) # Output: dict_items([('name', 'Alice'), ('age', 21)])
    ```
---

### More Useful Dictionary Methods ➕
# Unlock More Dictionary Power: Essential Methods

*   **`dictionary.update(another_dictionary)`:**  Merges the key-value pairs from `another_dictionary` into the original dictionary.  If there are overlapping keys, the values from `another_dictionary` **overwrite** the values in the original dictionary.

    ```python
    student_info = {"name": "Alice", "age": 21}
    more_info = {"major": "Physics", "city": "London"}

    student_info.update(more_info) # Merge more_info into student_info
    print(student_info) # Output: {'name': 'Alice', 'age': 21, 'major': 'Physics', 'city': 'London'}
    # Note: "major" is updated to "Physics" from more_info, other pairs are added
    ```
---

### More Useful Dictionary Methods ➕
# Unlock More Dictionary Power: Essential Methods

*   **`dictionary.popitem()`:** Removes and returns an **arbitrary** key-value pair from the dictionary (usually removes the last inserted item in Python versions before 3.7, but arbitrary in general in versions 3.7+ where dictionaries maintain insertion order). Raises a `KeyError` if the dictionary is empty.

    ```python
    student = {"name": "Alice", "age": 21, "major": "Computer Science"}
    last_item = student.popitem()
    print(student) # Output:  (Order might vary in Python 3.7+, e.g., {'name': 'Alice', 'age': 21})
    print(last_item) # Output: ('major', 'Computer Science') - the removed key-value pair as a tuple
    ```
---

### More Useful Dictionary Methods ➕
# Unlock More Dictionary Power: Essential Methods

**Your Turn!**

*   Create a dictionary representing some configuration settings (e.g., `config = {"database_host": "localhost", "port": 5432, "debug_mode": True}`).
*   Experiment with:
    *   `keys()`, `values()`, `items()` to view different parts of the dictionary. Observe how these view objects update when you change the dictionary.
    *   `update()` to merge another dictionary with your configuration dictionary.
    *   `popitem()` to remove arbitrary items.

**These methods provide essential tools for inspecting, manipulating, and combining dictionaries effectively!** ✨

**Next: Let's move on to the last core data structure we'll cover in this session: Sets!** ➡️

---

### Introduction to Sets 🧽
# Core Python Data Structures: Sets - Unordered Unique Collections
**Let's explore the final core data structure in this session: **Sets**.**

**What are Sets in Python?**

*   **Unordered collections of *unique* items:** Sets store elements in no particular order, and they **automatically eliminate duplicate values.**  If you add a duplicate, it's simply ignored.
*   **Mutable:** You can add and remove elements from a set after it's created, but you cannot modify existing elements directly (since elements are unique and their identity is based on their value).
*   **Elements must be immutable:** Set elements themselves must be of immutable types (like numbers, strings, tuples). You cannot have lists or dictionaries as elements within a set.
*   **Created using curly braces `{}`** or the `set()` constructor.
---

### Introduction to Sets 🧽
# Core Python Data Structures: Sets - Unordered Unique Collections
**Let's explore the final core data structure in this session: **Sets**.**

**Why are Sets Useful?  Uniqueness and Set Operations:**

*   **Efficient Membership Testing:** Sets are highly optimized for checking if an element is present in the set.  "Is this item in this collection?" is a very fast operation with sets.
*   **Removing Duplicate Items:**  Sets are a natural way to eliminate duplicates from a collection of items.  Simply convert a list to a set and back to a list to remove duplicates.
*   **Mathematical Set Operations:** Sets support standard mathematical set operations like:
    *   **Union:** Combine elements from two sets.
    *   **Intersection:** Find common elements between sets.
    *   **Difference:** Find elements present in one set but not in another.
    *   ...and more!
---

### Introduction to Sets 🧽
# Core Python Data Structures: Sets - Unordered Unique Collections
<br>

**In the next few slides, we will explore:**

*   **Creating Sets**
*   **Adding and Removing elements from Sets**
*   **Basic Set Operations (union, intersection, difference)**
*   **Set methods**
*   **...and more!**

**Get ready to discover the power of unique collections and set operations with Python Sets!** 💪

<!-- **(Session 3: Core Python - Data Structures - Sets)** -->

---

## Creating Sets 🛠️

# Creating Python Sets: Unique Collections

**Let's learn how to create sets in Python.  There are a couple of primary ways:**

**1. Creating a Set with Curly Braces `{}`:**

*   You can create a set by enclosing comma-separated values within curly braces `{}`.  **Note:** You cannot create an empty set using `{}`, as that creates an empty dictionary (we'll see how to create empty sets bein the next slide).
---

## Creating Sets 🛠️

# Creating Python Sets: Unique Collections

**Let's learn how to create sets in Python.  There are a couple of primary ways:**

**1. Creating a Set with Curly Braces `{}`:**

```python
# Creating a set of fruits
my_set = {"apple", "banana", "orange"}
print(my_set)  # Output: {'orange', 'banana', 'apple'} (order may vary as sets are unordered)
print(type(my_set)) # Output: <class 'set'>

# Set of numbers
number_set = {1, 2, 3, 4, 5}
print(number_set) # Output: {1, 2, 3, 4, 5} (order may vary)

# Sets automatically remove duplicates
duplicate_set = {1, 2, 2, 3, 3, 3}
print(duplicate_set) # Output: {1, 2, 3} (duplicates are removed)

# Sets can contain different immutable data types
mixed_set = {1, "hello", 3.14, True, (1, 2)} # Tuple is immutable, so allowed in set
print(mixed_set) # Output: {True, 1, 3.14, 'hello', (1, 2)} (order may vary)
```
---

## Creating Sets 🛠️

# Creating Python Sets: Unique Collections

**Let's learn how to create sets in Python.  There are a couple of primary ways:**

**2. Creating a Set using the `set()` Constructor:**

*   The `set()` constructor can be used to create sets from other iterable objects (like lists, tuples, strings) or to create an empty set. Check the next slide.

---

## Creating Sets 🛠️

# Creating Python Sets: Unique Collections

**Let's learn how to create sets in Python.  There are a couple of primary ways:**

**2. Creating a Set using the `set()` Constructor:**

```python
# Creating an empty set (important - use set() for empty sets, not {})
empty_set = set()
print(empty_set) # Output: set()
print(type(empty_set)) # Output: <class 'set'>

# Creating a set from a list
fruit_list = ["apple", "banana", "orange", "apple"] # List with duplicates
fruit_set = set(fruit_list) # Create set from list - duplicates removed
print(fruit_set) # Output: {'orange', 'banana', 'apple'} (duplicates removed, order may vary)

# Creating a set from a string
string_set = set("letters")
print(string_set) # Output: {'l', 'e', 't', 'r', 's'} (unique characters from the string, order may vary)

# Creating a set from a tuple
tuple_set = set((10, 20, 30, 10)) # Tuple with duplicates
print(tuple_set) # Output: {10, 20, 30} (duplicates removed, order may vary)
```
---

## Creating Sets 🛠️

# Creating Python Sets: Unique Collections 
<br>

**Important Note:** Sets are unordered. The output order when you print a set may not be the same as the order in which you added elements or defined them.  Don't rely on element order in sets.

**Your Turn!**

*   In your Jupyter Notebook, create sets using both methods.
*   Create sets with various data types (numbers, strings, tuples).
*   Create a set from a list that contains duplicate items - observe how sets automatically remove duplicates.
*   Try to create a set from a mutable object like a list - you'll see a `TypeError` as set elements must be immutable.

---

### Adding and Removing Set Elements

# Modifying Sets: Adding and Removing Elements

**Sets are mutable, so you can add and remove elements after they are created.**

**1. Adding Elements to a Set:**

*   **`set.add(item)`:** Adds a single `item` to the set. If the item is already present, `add()` has no effect (sets only store unique elements).

    ```python
    fruits = {"apple", "banana"}
    print(fruits) # Output: {'banana', 'apple'} (order may vary)

    fruits.add("orange") # Add "orange"
    print(fruits) # Output: {'orange', 'banana', 'apple'} (order may vary)

    fruits.add("apple") # Add "apple" again - no effect as "apple" is already present
    print(fruits) # Output: {'orange', 'banana', 'apple'} (still the same set)
    ```
---

### Adding and Removing Set Elements

# Modifying Sets: Adding and Removing Elements

**Sets are mutable, so you can add and remove elements after they are created.**

**1. Adding Elements to a Set (cntd.):**

*   **`set.update(another_set_or_iterable)`:** Adds multiple elements to the set from another set or any iterable (like a list, tuple, string).  Duplicates are automatically ignored.

    ```python
    numbers = {1, 2, 3}
    new_numbers = [4, 5, 5, 6] # List with a duplicate

    numbers.update(new_numbers) # Add elements from list - duplicate '5' is ignored
    print(numbers) # Output: {1, 2, 3, 4, 5, 6}

    vowels = {'a', 'e', 'i'}
    vowels.update("ou") # Add characters from string "ou"
    print(vowels) # Output: {'e', 'u', 'i', 'o', 'a'} (order may vary)
    ```
---

### Adding and Removing Set Elements

# Modifying Sets: Adding and Removing Elements

**Sets are mutable, so you can add and remove elements after they are created.**

**2. Removing Elements from a Set:**

*   **`set.remove(item)`:** Removes a specific `item` from the set. Raises a `KeyError` if the item is not found in the set.

    ```python
    colors = {"red", "green", "blue"}
    colors.remove("blue")
    print(colors) # Output: {'red', 'green'}

    # colors.remove("yellow") # This would cause a KeyError: 'yellow' - as "yellow" is not in the set
    ```
---

### Adding and Removing Set Elements

# Modifying Sets: Adding and Removing Elements

**Sets are mutable, so you can add and remove elements after they are created.**

**2. Removing Elements from a Set (cntd.):**

*   **`set.discard(item)`:** Removes a specific `item` from the set **if it is present**. If the item is not in the set, `discard()` does **nothing** (does not raise an error).  Safer than `remove()` if you are unsure if the item exists.

    ```python
    colors = {"red", "green", "blue"}
    colors.discard("green")
    print(colors) # Output: {'red', 'blue'}

    colors.discard("yellow") # No error, even though "yellow" is not in the set
    print(colors) # Output: {'red', 'blue'} (set remains unchanged)
    ```
---

### Adding and Removing Set Elements

# Modifying Sets: Adding and Removing Elements

**Sets are mutable, so you can add and remove elements after they are created.**

**2. Removing Elements from a Set (cntd..):**

*   **`set.pop()`:** Removes and returns an **arbitrary** element from the set.  Raises a `KeyError` if the set is empty. Since sets are unordered, you don't know which element will be popped.

    ```python
    my_set = {10, 20, 30, 40}
    removed_item = my_set.pop() # Remove and return an arbitrary element
    print(my_set) # Output: (e.g.) {20, 30, 40} -  (one element removed, but which one is arbitrary)
    print(removed_item) # Output: (e.g.) 10 - the removed item
    ```

*   **`set.clear()`:** Removes all elements from the set, making it empty.

    ```python
    my_set = {1, 2, 3}
    my_set.clear()
    print(my_set) # Output: set() - empty set
    ```
---

### Adding and Removing Set Elements

# Modifying Sets: Adding and Removing Elements

**Sets are mutable, so you can add and remove elements after they are created.**

**Your Turn!**

*   Create a set of numbers or letters.
*   Practice:
    *   Adding elements using `add()` and `update()`.
    *   Removing elements using `remove()`, `discard()`, and `pop()`.
    *   Clearing the set using `clear()`.
    *   Experiment with adding duplicate items - observe that sets maintain uniqueness.
    *   Try to `remove()` an item that is not in the set - observe the `KeyError`, and contrast with `discard()`.

**Next: Let's explore the powerful Set Operations - union, intersection, difference, and more!** ➡️

---
layout: two-cols-header
---

### Set Operations: Union & Intersection ⋃ ⋂
# Set Operations: Union and Intersection

**Sets in Python are powerful because they support standard mathematical set operations.** Let's explore some of the fundamental ones:
::left::
**1. Union (⋃): Combining Sets**

*   The **union** of two sets creates a *new* set containing all elements that are in *either* set (or both).  Duplicates are automatically removed in the resulting set because sets only store unique elements.
::right::
*   **Methods to perform union:**
    *   **`set1.union(set2)`:** Returns a new set that is the union of `set1` and `set2`.
    *   **`set1 | set2` (using the `|` operator):**  A more concise way to get the union.
    *   **`set1.update(set2)`:**  Modifies `set1` in-place by adding all elements from `set2` into `set1`.  This is an in-place operation and doesn't return a new set.
---

### Set Operations: Union & Intersection ⋃ ⋂
# Set Operations: Union


```python
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}

# Method 1: using union() - returns a new set
union_set_method = set1.union(set2)
print(union_set_method) # Output: {1, 2, 3, 4, 5, 6}

# Method 2: using | operator - returns a new set
union_set_operator = set1 | set2
print(union_set_operator) # Output: {1, 2, 3, 4, 5, 6}

# Method 3: using update() - modifies set1 in-place
set3 = {1, 2, 3, 4} # Create a copy of set1 to avoid modifying original
set4 = {3, 4, 5, 6}
set3.update(set4) # Modifies set3
print(set3) # Output: {1, 2, 3, 4, 5, 6}
```
---

### Set Operations: Union & Intersection ⋃ ⋂
# Set Operations: Union and Intersection

**Sets in Python are powerful because they support standard mathematical set operations.** Let's explore some of the fundamental ones:

**2. Intersection (⋂): Common Elements**

*   The **intersection** of two sets creates a *new* set containing only the elements that are present in *both* sets.
*   **Methods to perform intersection:**
    *   **`set1.intersection(set2)`:** Returns a new set containing the intersection of `set1` and `set2`.
    *   **`set1 & set2` (using the `&` operator):** A more concise way to get the intersection.
    *   **`set1.intersection_update(set2)`:** Modifies `set1` in-place, keeping only the elements that are also present in `set2`.  In-place operation.
---

### Set Operations: Union & Intersection ⋃ ⋂
# Set Operations: Union 

```python
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}

# Method 1: using intersection() - returns a new set
intersection_set_method = set1.intersection(set2)
print(intersection_set_method) # Output: {3, 4}

# Method 2: using & operator - returns a new set
intersection_set_operator = set1 & set2
print(intersection_set_operator) # Output: {3, 4}

# Method 3: using intersection_update() - modifies set1 in-place
set5 = {1, 2, 3, 4} # Create a copy of set1
set6 = {3, 4, 5, 6}
set5.intersection_update(set6) # Modifies set5
print(set5) # Output: {3, 4}
```
---

### Set Operations: Union & Intersection ⋃ ⋂
# Set Operations: Union and Intersection
<br>

**Your Turn!**

*   Create two sets of numbers or fruits.
*   Practice:
    *   Finding the union of the sets using `union()` and `|` operator.
    *   Finding the intersection of the sets using `intersection()` and `&` operator.
    *   Using `update()` and `intersection_update()` to modify sets in-place.
*   Print the resulting sets to observe the results of these operations.

---
layout: two-cols-header
---

## Set Operations: Difference & Subset/Superset ➖ ⊆ ⊇

# Set Operations: Difference and Subset/Superset

**Let's continue exploring more useful set operations in Python.**
::left::
**1. Difference (—): Elements in One Set but Not the Other**

*   The **difference** of two sets (`set1 - set2`) creates a *new* set containing elements that are in `set1` but **not** in `set2`.
*   Order matters for difference: `set1 - set2` is not the same as `set2 - set1`.
::right::
*   **Methods to perform difference:**
    *   **`set1.difference(set2)`:** Returns a new set with elements in `set1` but not in `set2`.
    *   **`set1 - set2` (using the `-` operator):**  A concise way to get the difference.
    *   **`set1.difference_update(set2)`:** Modifies `set1` in-place, removing elements that are also present in `set2`. In-place operation.
---

### Set Operations: Difference & Subset/Superset ➖ ⊆ ⊇

# Set Operations: Difference and Subset/Superset
<br>

**1. Difference (—): Elements in One Set but Not the Other**

```python
set1 = {1, 2, 3, 4, 5}
set2 = {3, 4, 5, 6, 7}

# Method 1: using difference() - returns a new set
difference_set_method = set1.difference(set2)
print(difference_set_method) # Output: {1, 2} (elements in set1 but not in set2)

# Method 2: using - operator - returns a new set
difference_set_operator = set1 - set2
print(difference_set_operator) # Output: {1, 2}

# Method 3: using difference_update() - modifies set1 in-place
set3 = {1, 2, 3, 4, 5} # Create a copy of set1
set4 = {3, 4, 5, 6, 7}
set3.difference_update(set4) # Modifies set3
print(set3) # Output: {1, 2}
```
---

### Set Operations: Difference & Subset/Superset ➖ ⊆ ⊇

# Set Operations: Difference and Subset/Superset
<br>

**2. Subset and Superset Relationships (⊆ ⊇): Checking Set Containment**

*   **Subset (⊆):**  A set `set1` is a **subset** of `set2` if all elements of `set1` are also present in `set2`.
    *   **`set1.issubset(set2)`:** Returns `True` if `set1` is a subset of `set2`, `False` otherwise.
    *   **`set1 <= set2` (using the `<=` operator):**  Concise way to check for subset.  Use `<` for *strict* subset (set1 is a subset and not equal to set2).
    ```python
    set_a = {1, 2, 3}
    set_b = {1, 2, 3, 4, 5}
    set_c = {3, 4, 5, 6}
    print(set_a.issubset(set_b)) # Output: True (set_a is a subset of set_b)
    print(set_a <= set_b)        # Output: True (subset check using operator)
    print(set_b.issubset(set_a)) # Output: False (set_b is not a subset of set_a)
    print(set_a <= set_a)        # Output: True (a set is a subset of itself)
    print(set_a < set_a)         # Output: False (not a strict subset of itself)
    print(set_a < set_b)         # Output: True (strict subset - set_a is smaller)
    ```
---

### Set Operations: Difference & Subset/Superset ➖ ⊆ ⊇

# Set Operations: Difference and Subset/Superset
<br>

*   **Superset (⊇):** A set `set1` is a **superset** of `set2` if `set1` contains all elements of `set2`.
    *   **`set1.issuperset(set2)`:** Returns `True` if `set1` is a superset of `set2`, `False` otherwise.
    *   **`set1 >= set2` (using the `>=` operator):** Concise way to check for superset. Use `>` for *strict* superset (set1 is a superset and not equal to set2).

    ```python
    set_a = {1, 2, 3}
    set_b = {1, 2, 3, 4, 5}

    print(set_b.issuperset(set_a)) # Output: True (set_b is a superset of set_a)
    print(set_b >= set_a)        # Output: True (superset check using operator)
    print(set_a.issuperset(set_b)) # Output: False (set_a is not a superset of set_b)
    print(set_b >= set_b)        # Output: True (a set is a superset of itself)
    print(set_b > set_b)         # Output: False (not a strict superset of itself)
    print(set_b > set_a)         # Output: True (strict superset - set_b is larger)
    ```
---

### Set Operations: Difference & Subset/Superset ➖ ⊆ ⊇

# Set Operations: Difference and Subset/Superset
<br>

**Your Turn!**

*   Create two sets of numbers or items of your choice.
*   Practice:
    *   Finding the difference between the sets using `difference()` and `-` operator (try both `set1 - set2` and `set2 - set1` to see the order difference).
    *   Checking for subset and superset relationships using `issubset()`, `issuperset()`, `<=`, `<`, `>=`, and `>`.
*   Experiment with different sets and observe the results of these set operations.
---

### Set Operations: Difference & Subset/Superset ➖ ⊆ ⊇

# Set Operations: Difference and Subset/Superset
<br>

**Key Takeaway:**  Python sets provide a rich set of operations for efficiently working with collections of unique items, including union, intersection, difference, and set relationship checks. These are very useful in various programming scenarios, especially when dealing with data analysis, data cleaning, and algorithm design.

**Next: Let's quickly recap Session 3: Core Python DS and see what's coming up in Session 4!** 🚀
---

## Session 3 Summary - Core Python Data Structures ✅
# Session 3 Wrap-up: Mastering Core Data Structures

**Congratulations on completing Session 3: "Core Python Data Structures"!** 🎉

**Let's quickly summarize the key data structures we've explored in this session:**

*   **Lists:** Ordered, mutable sequences. Versatile for storing and manipulating collections of items.  `[]` 🗂️
*   **Tuples:** Ordered, *immutable* sequences.  For fixed collections, data integrity, and sometimes performance. `()` 📦
*   **Dictionaries:** Unordered collections of key-value pairs.  For efficient data lookup and representing mappings. `{}` 🔑
*   **Sets:** Unordered collections of *unique* items.  For membership testing, removing duplicates, and set operations. `set()` 🧽
---

## Session 3 Summary - Core Python Data Structures ✅
# Session 3 Wrap-up: Mastering Core Data Structures

**Congratulations on completing Session 3: "Core Python Data Structures"!** 🎉

**For each data structure, we covered:**

*   **Creation:** How to create instances of each data structure.
*   **Accessing Elements:**  Using indexing, slicing (for lists and tuples), and keys (for dictionaries).
*   **Modification (if mutable):**  Adding, removing, and updating elements (for lists and dictionaries, adding/removing for sets).
*   **Essential Methods:** Key built-in methods for common operations on each data structure.
*   **Specific Use Cases and Advantages** of each data structure.
---

## Session 3 Summary - Core Python Data Structures ✅
# Session 3 Wrap-up: Mastering Core Data Structures

**Congratulations on completing Session 3: "Core Python Data Structures"!** 🎉

**Key Takeaway from Session 3:**

*   You now have a solid foundation in Python's core data structures: Lists, Tuples, Dictionaries, and Sets.  These are fundamental building blocks for writing effective Python programs and handling data in various forms.  Mastering these data structures is crucial for your Python journey!

---

## Slide 64: Next Steps - Ready for Control Flow! 🚀
# What's Next?  Control the Flow with Session 4!

**You've completed Session 3 and significantly expanded your Python toolkit!** Excellent work! 👏

**In Session 4: "Control Flow - Logic in Your Code," we will learn how to:**

*   **Make decisions in your code using `if`, `elif`, `else` statements.**  Branch your program's execution based on conditions. 🚦
*   **Repeat actions using `for` loops** - iterate over sequences and collections. 🔄
*   **Repeat actions based on conditions using `while` loops.** Repeat until a condition is met. 🔁
*   **Control loop execution with `break` and `continue` statements.** Fine-tune loop behavior. 🛠️
---

## Slide 64: Next Steps - Ready for Control Flow! 🚀
# What's Next?  Control the Flow with Session 4!

**You've completed Session 3 and significantly expanded your Python toolkit!** Excellent 

**Before Session 4:**

*   **Review the data structures from Session 3 (Lists, Tuples, Dictionaries, Sets).**  Make sure you are comfortable creating them, accessing elements, and using basic methods. You'll be using these data structures extensively in future sessions, including Session 4!
*   **Optional:**  Practice writing small code snippets in Jupyter Notebook using the data structures you've learned.  Experiment with combining different data structures.

**Get ready to add logic and control to your Python programs in Session 4: Control Flow!** 🚀

**See you in Session 4!** 👋


