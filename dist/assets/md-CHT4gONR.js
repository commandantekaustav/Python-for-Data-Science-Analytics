import{b as s,o as l,w as i,g as e,B as t,v as u,x as m,C as n}from"./modules/vue-DcZKNubr.js";import{I as c}from"./slidev/default-DITZbOMS.js";import{u as f,f as d}from"./slidev/context-DOn3OHKD.js";import"./index-DTPcApfY.js";import"./modules/shiki-BYsr0BdZ.js";const B={__name:"s8.md__slidev_466",setup(p){const{$clicksContext:o,$frontmatter:a}=f();return o.setup(),(y,r)=>(l(),s(c,u(m(n(d)(n(a),465))),{default:i(()=>r[0]||(r[0]=[e("h3",null,"Benefits of Generators - Memory Efficiency ðŸ¥‡",-1),e("h1",null,"Benefits of Generators: Memory Efficiency",-1),e("p",null,[e("strong",null,"One of the most significant advantages of generators is their memory efficiency, especially when working with large sequences of data.")],-1),e("p",null,[e("strong",null,"Generators are Memory-Efficient Because They are Lazy:")],-1),e("ul",null,[e("li",null,[e("strong",null,"Lazy Evaluation:"),t(" Generators produce values only when they are asked for (on demand), during iteration. They donâ€™t compute and store all values in memory upfront.")]),e("li",null,[e("strong",null,"Value Generation on Demand:"),t(' Instead of creating an entire list or tuple in memory, a generator computes and yields one item at a time, then "forgets" it (in terms of memory usage). It only remembers the state necessary to produce the '),e("em",null,"next"),t(" item.")]),e("li",null,[e("strong",null,"No large data structures in memory:"),t(" Generators avoid creating and holding large lists or other data structures in memory to store entire sequences.")])],-1)])),_:1},16))}};export{B as default};
