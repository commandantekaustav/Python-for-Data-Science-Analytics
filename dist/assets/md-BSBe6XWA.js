import{_ as u}from"./slidev/VClicks-B6c2E_rL.js";import{b as m,o as p,w as o,g as e,i as d,e as r,B as n,v as y,x as c,C as a}from"./modules/vue-DYRo_Lls.js";import{I as f}from"./slidev/default-COya6M-5.js";import{u as h,f as g}from"./slidev/context-Yz-4lzjv.js";import"./index-Q9xIr-xQ.js";import"./modules/shiki-NVXounY8.js";const L={__name:"session-1.md__slidev_537",setup(P){const{$clicksContext:l,$frontmatter:i}=h();return l.setup(),(_,t)=>{const s=u;return p(),m(f,y(c(a(g)(a(i),536))),{default:o(()=>[t[2]||(t[2]=e("h2",null,"NumPy vs. Python Lists - Why NumPy? ðŸš€",-1)),d(" # Module 2: Data Manipulation with pandas and NumPy "),r(s,null,{default:o(()=>t[0]||(t[0]=[e("h3",null,[e("strong",null,"NumPy vs. Python Lists: Why Choose NumPy?")],-1),e("p",null,[e("strong",null,"Python lists are versatile, but for numerical computations, NumPy arrays offer significant advantages. Letâ€™s explore why NumPy arrays are often the preferred choice for numerical tasks.")],-1),e("p",null,[e("strong",null,"Key Advantages of NumPy Arrays over Python Lists:")],-1)])),_:1}),r(s,{depth:"2"},{default:o(()=>t[1]||(t[1]=[e("ul",null,[e("li",null,[e("strong",null,"1. Performance (Speed):"),e("ul",null,[e("li",null,[e("strong",null,"Compiled Code:"),n(" NumPy operations are implemented in highly optimized, compiled languages like C and Fortran, making them significantly faster than equivalent Python list operations (which are interpreted).")]),e("li",null,[e("strong",null,"Contiguous Memory:"),n(" NumPy arrays store elements in contiguous memory blocks, allowing for efficient access and vectorized operations. Python lists, in contrast, store elements as pointers to objects scattered in memory.")]),e("li",null,[e("strong",null,"Homogeneous Data Types:"),n(" NumPy arrays enforce homogeneous data types, which allows for further optimizations. Python lists can hold elements of mixed types, adding overhead.")])])])],-1)])),_:1})]),_:1},16)}}};export{L as default};
