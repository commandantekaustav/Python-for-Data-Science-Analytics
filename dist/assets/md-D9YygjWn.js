import{b as a,o as i,w as u,g as e,B as n,v as s,x as c,C as l}from"./modules/vue-DYRo_Lls.js";import{I as m}from"./slidev/default-COya6M-5.js";import{u as p,f as d}from"./slidev/context-Yz-4lzjv.js";import"./index-Q9xIr-xQ.js";import"./modules/shiki-NVXounY8.js";const _={__name:"session-4.md__slidev_684",setup(f){const{$clicksContext:o,$frontmatter:r}=p();return o.setup(),(g,t)=>(i(),a(m,s(c(l(d)(l(r),683))),{default:u(()=>t[0]||(t[0]=[e("h3",null,[n("UFunc Features: "),e("code",null,"out"),n(" argument Summary ✅")],-1),e("p",null,[e("strong",null,[n("Summary of the "),e("code",null,"out"),n(" argument:")])],-1),e("ul",null,[e("li",null,[e("strong",null,"Control over Output Location:"),n(" The "),e("code",null,"out"),n(" argument provides explicit control over where UFunc results are written.")]),e("li",null,[e("strong",null,"In-place Operation Capability:"),n(' Enables "in-place"-like operations by writing results directly into pre-existing arrays, avoiding new array creation.')]),e("li",null,[e("strong",null,"Memory Efficiency:"),n(" Can improve memory efficiency, especially with large arrays and repeated calculations, by reducing memory allocation overhead.")]),e("li",null,[e("strong",null,"Optional but Powerful:"),n(" The "),e("code",null,"out"),n(" argument is optional but offers significant flexibility for memory management and optimization when working with NumPy UFuncs.")])],-1),e("p",null,[e("strong",null,[n("Having explored UFunc Methods and the "),e("code",null,"out"),n(" argument, we’ve covered key "),e("em",null,"Features"),n(" that enhance UFunc functionality!")])],-1),e("p",null,[e("strong",null,[n("Next, we will delve into understanding the "),e("em",null,"Performance Benefits"),n(" of using UFuncs!")])],-1)])),_:1},16))}};export{_ as default};
