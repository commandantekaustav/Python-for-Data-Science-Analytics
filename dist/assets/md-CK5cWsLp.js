import{b as s,o as i,w as l,g as e,B as o,v as u,x as p,C as r}from"./modules/vue-DYRo_Lls.js";import{I as m}from"./slidev/default-COya6M-5.js";import{u as c,f as d}from"./slidev/context-Yz-4lzjv.js";import"./index-Q9xIr-xQ.js";import"./modules/shiki-NVXounY8.js";const _={__name:"session-2.md__slidev_569",setup(f){const{$clicksContext:t,$frontmatter:a}=c();return t.setup(),(y,n)=>(i(),s(m,u(p(r(d)(r(a),568))),{default:l(()=>n[0]||(n[0]=[e("h2",null,"NumPy Array Operations - Introduction ðŸš€",-1),e("h3",null,[e("strong",null,"What are Array Operations in NumPy?")],-1),e("ul",null,[e("li",null,[e("strong",null,"Element-wise Operations:"),o(" Most operations in NumPy are performed "),e("strong",null,"element-wise"),o(". This means that when you apply an operation between two arrays (or between an array and a scalar), the operation is carried out on corresponding elements.")]),e("li",null,[e("strong",null,"Vectorized Computations:"),o(" NumPyâ€™s array operations are "),e("strong",null,"vectorized"),o(", which is a key concept for performance. Vectorization allows operations to be performed on entire arrays efficiently, without explicit loops in Python, leveraging optimized low-level implementations.")]),e("li",null,[e("strong",null,"Broadcasting (Coming Soon):"),o(" NumPy also features powerful "),e("strong",null,"broadcasting"),o(" rules that enable operations on arrays with different shapes (under certain conditions). Weâ€™ll explore broadcasting in more detail shortly.")]),e("li",null,[e("strong",null,"Foundation for Data Manipulation:"),o(" Understanding array operations is crucial for performing complex data transformations, calculations, and analyses using NumPy and pandas.")])],-1)])),_:1},16))}};export{_ as default};
