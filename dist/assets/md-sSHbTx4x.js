import{b as l,o as s,w as i,g as e,B as n,v as u,x as m,C as o}from"./modules/vue-DYRo_Lls.js";import{I as c}from"./slidev/default-COya6M-5.js";import{u as h,f as d}from"./slidev/context-Yz-4lzjv.js";import"./index-Q9xIr-xQ.js";import"./modules/shiki-NVXounY8.js";const v={__name:"session-5.md__slidev_702",setup(f){const{$clicksContext:a,$frontmatter:r}=h();return a.setup(),(p,t)=>(s(),l(c,u(m(o(d)(o(r),701))),{default:i(()=>t[0]||(t[0]=[e("h3",null,"Reshaping Arrays: Summary ✅",-1),e("p",null,[e("strong",null,"Summary of Reshaping Techniques:")],-1),e("ul",null,[e("li",null,[e("strong",null,[e("code",null,".reshape(new_shape)"),n(":")]),n(" Changes the shape of an array "),e("em",null,"without"),n(" changing the data. Flexible, can reshape to higher or lower dimensions. Use "),e("code",null,"-1"),n(" for automatic dimension inference.")]),e("li",null,[e("strong",null,[e("code",null,".flatten()"),n(":")]),n(" Always returns a "),e("strong",null,"1D copy"),n(" of the original array. Modifications to the flattened array "),e("em",null,"do not"),n(" affect the original.")]),e("li",null,[e("strong",null,[e("code",null,".ravel()"),n(":")]),n(" Returns a "),e("strong",null,"1D view"),n(" of the original array "),e("em",null,"if possible"),n(". Modifications to the raveled array "),e("em",null,"may"),n(" affect the original array. Often more memory-efficient than "),e("code",null,".flatten()"),n(".")])],-1),e("p",null,[e("strong",null,"Choose the reshaping method that best suits your needs based on whether you need to change dimensionality, require a copy or a view, and memory considerations.")],-1),e("p",null,[e("strong",null,"Next, we’ll move on to the next key array manipulation topic: Stacking Arrays!")],-1)])),_:1},16))}};export{v as default};
