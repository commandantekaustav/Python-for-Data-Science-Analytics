import{b as r,o as i,w as l,g as e,B as t,v as u,x as p,C as n}from"./modules/vue-DYRo_Lls.js";import{I as c}from"./slidev/default-COya6M-5.js";import{u as m,f}from"./slidev/context-Yz-4lzjv.js";import"./index-Q9xIr-xQ.js";import"./modules/shiki-NVXounY8.js";const x={__name:"session-4.md__slidev_633",setup(d){const{$clicksContext:a,$frontmatter:o}=m();return a.setup(),(g,s)=>(i(),r(c,u(p(n(f)(n(o),632))),{default:l(()=>s[0]||(s[0]=[e("h3",null,"UFuncs and Broadcasting - Concept ðŸ“¡",-1),e("p",null,[e("strong",null,"UFuncs and Broadcasting: Seamless Shape Compatibility")],-1),e("p",null,[t("One of the most powerful features of UFuncs is their built-in support for "),e("strong",null,"broadcasting"),t(". This allows UFuncs to operate on arrays that have "),e("em",null,"different shapes"),t(", as long as those shapes are compatible according to NumPyâ€™s broadcasting rules.")],-1),e("p",null,[e("strong",null,"Broadcasting in UFuncs Means:")],-1),e("ul",null,[e("li",null,[e("strong",null,"Flexibility:"),t(" Perform element-wise operations between arrays of different, compatible shapes.")]),e("li",null,[e("strong",null,"Efficiency:"),t(" Avoid unnecessary data duplication, making operations memory-efficient.")]),e("li",null,[e("strong",null,"Conciseness:"),t(" Write operations that work intuitively on arrays with varying shapes.")])],-1)])),_:1},16))}};export{x as default};
