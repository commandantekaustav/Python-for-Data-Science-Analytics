import{b as s,o as i,w as l,g as e,B as t,v as c,x as m,C as o}from"./modules/vue-DcZKNubr.js";import{I as u}from"./slidev/default-DITZbOMS.js";import{u as f,f as g}from"./slidev/context-DOn3OHKD.js";import"./index-DTPcApfY.js";import"./modules/shiki-BYsr0BdZ.js";const b={__name:"s8.md__slidev_469",setup(p){const{$clicksContext:r,$frontmatter:a}=f();return r.setup(),(d,n)=>(i(),s(u,c(m(o(g)(o(a),468))),{default:l(()=>n[0]||(n[0]=[e("h3",null,"Benefits of Generators - Memory Efficiency ðŸ¥‡",-1),e("h1",null,"Benefits of Generators: Memory Efficiency",-1),e("p",null,[e("strong",null,"One of the most significant advantages of generators is their memory efficiency, especially when working with large sequences of data.")],-1),e("p",null,[e("strong",null,"Explanation:")],-1),e("ul",null,[e("li",null,[t("The list comprehension "),e("code",null,"large_list"),t(" creates a list containing 1 million numbers. This list occupies a significant amount of memory (several megabytes).")]),e("li",null,[t("The generator expression "),e("code",null,"large_generator"),t(" creates a generator object that "),e("em",null,"can"),t(" produce 1 million numbers, but it doesnâ€™t store them all in memory. The generator object itself is very small and has a constant memory footprint (around 128 bytes), regardless of the potential size of the sequence it can generate.")])],-1),e("p",null,[e("strong",null,"Generators are ideal for processing large datasets, reading large files, or working with infinite sequences where you cannot or do not want to load everything into memory at once. They are a cornerstone of memory-efficient Python programming!")],-1)])),_:1},16))}};export{b as default};
