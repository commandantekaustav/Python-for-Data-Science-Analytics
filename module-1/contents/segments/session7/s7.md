---
transition: slide-left
align: centre
title: Error Handling - Exceptions, Assertions & Basic Type Annotations
layout: section
---

# Session 7: 
## Error Handling - Exceptions, Assertions & Basic Type Annotations
---

## Welcome to Error Handling (and more!) üöÄ

**Welcome to Session 7!** In this session, we will focus on making your Python code more robust and readable by exploring:

1.  **Error Handling with Exceptions:**  We'll delve into how to anticipate, catch, and gracefully handle errors that can occur during program execution using Python's exception handling mechanism. This is crucial for writing reliable programs that don't crash unexpectedly.

2.  **Assertions (`assert` statements):** We will learn about `assert` statements, a powerful tool for internal program checks and debugging. Assertions help you verify assumptions in your code and catch logical errors early in development.

3.  **(Brief Introduction) Basic Type Annotations:** We will also get a first glimpse into type annotations (or type hints) in Python. Type annotations are a way to add optional type information to your Python code. While Python is dynamically typed, type annotations improve code readability, help with static analysis, and can catch type-related errors during development (though not at runtime in standard Python).

---

## Welcome to Error Handling (and more!) üöÄ

**In this Session 7, we will cover:**

*   **What are Errors and Exceptions?** Types of errors in Python.
*   **Exception Handling with `try-except` blocks:** Catching and handling exceptions.
*   **Handling Specific Exceptions:**  `TypeError`, `ValueError`, `FileNotFoundError`, etc.
*   **`else` and `finally` blocks in `try-except`**.
*   **Raising Exceptions Manually.**
*   **Assertions with `assert` statements:** Using assertions for debugging and internal checks.
*   **(Brief Intro) Basic Type Annotations:**  Syntax and benefits of type hints for readability and static analysis.

**By the end of this session, you will be able to write more robust, easier-to-debug, and more readable Python code by effectively handling errors, using assertions, and understanding basic type annotations!**

**Let's begin with understanding Errors and Exceptions in Python!** ‚û°Ô∏è

---

### Exception Handling - `try-except` Blocks üõ°Ô∏è
# Exception Handling with `try-except` Blocks

**`try-except` blocks are the core mechanism in Python for handling exceptions (runtime errors) gracefully. They allow you to:**

*   **Anticipate potential errors:** Identify sections of your code that might raise exceptions.
*   **Catch exceptions:** Intercept and handle specific exceptions if they occur.
*   **Prevent program crashes:** Stop exceptions from abruptly terminating your program.
*   **Implement error recovery or alternative actions:**  Decide what your program should do when an error occurs (e.g., display an error message, try a different approach, log the error, etc.).
---

### Exception Handling - Basic Syntax of a `try-except` Block üõ°Ô∏è
<!-- # Exception Handling with `try-except` Blocks -->

<!-- **`try-except` blocks are the core mechanism in Python for handling exceptions (runtime errors) gracefully. They allow you to:** -->

<!-- **Basic Syntax of a `try-except` Block:** -->

```python
try:
    # Code that might raise an exception (the "risky" code)
    # ... potentially error-prone statements ...

except ExceptionType1 as e1:
    # Code to handle ExceptionType1 (if it occurs in the 'try' block)
    # ... actions to take when ExceptionType1 happens ...
    # ... e1 is a variable that will hold the exception object (optional to use)
except ExceptionType2 as e2:
    # Code to handle ExceptionType2 (if it occurs)
    # ... actions for ExceptionType2 ...
# ... You can have multiple 'except' blocks to handle different exception types ...

except: # Bare 'except' - catches ANY exception (generally discouraged for broad use)
    # Code to handle any other exception type not specifically caught above
    # ... fallback error handling ...
else: # Optional 'else' block
    # Code that will be executed if NO exceptions occurred in the 'try' block
    # ... actions to take if the 'try' block was successful ...
finally: # Optional 'finally' block
    # Code that will ALWAYS be executed, regardless of whether an exception occurred or not
    # ... cleanup code (e.g., closing files, releasing resources) ...
# Program execution continues normally after the try-except block (if the exception was handled)
```
---

### Exception Handling - Basic Syntax of a `try-except` Block üõ°Ô∏è

**Explanation of `try-except` components:**
- **`try:` block:**
    - Encloses the code that you want to monitor for potential exceptions.
    - If any exception occurs within the `try` block, Python immediately jumps to the `except` block(s).
- `except ExceptionType as variable:` **block(s):**
    - Follows the `try` block. You can have one or more `except` blocks.
    - `ExceptionType:` Specifies the type of exception you want to catch (e.g., `TypeError`, `ValueError`, `ZeroDivisionError`, `FileNotFoundError`, or a more general exception type like `Exception` or `BaseException`).
    - `as variable` **(optional):** Allows you to assign the caught exception object to a variable (e.g., `e`, `err`, `ex`) so you can access details about the exception (like the error message).
    - **Handler code:** The code inside the `except` block is executed *only if* an exception of the specified `ExceptionType` (or a compatible subclass) occurs in the `try` block.
---

### Exception Handling - Basic Syntax of a `try-except` Block üõ°Ô∏è

**Explanation of `try-except` components:**
- `except:` **(bare except):**
    - Catches *any exception* that is not caught by the preceding specific `except` blocks.
    - **Generally discouraged** for broad use because it can hide unexpected errors and make debugging harder. It's better to catch specific exception types whenever possible.
- `else:` **block (optional):**
    - Executed *only if* the code in the `try` block completes *without raising any exceptions*.
    - Useful for code that should run when the "try" part is successful.
---

### Exception Handling - Basic Syntax of a `try-except` Block üõ°Ô∏è

**Explanation of `try-except` components:**

- `finally:` **block (optional):**
    - Executed **always,** regardless of whether an exception occurred in the `try` block or not, and whether the exception was handled or not.
    - Typically used for **cleanup actions** that must be performed no matter what (e.g., closing files, releasing resources, logging).

**Next: Let's look at examples of using try-except to handle specific exceptions! ‚û°Ô∏è**

---

### `try-except` Examples - Handling Specific Exceptions üéØ
# Handling Specific Exception Types using `try-except`

**Let's look at practical examples of using `try-except` blocks to handle specific types of exceptions.**

**Example 1: Handling `ZeroDivisionError`**

```python
def divide_numbers(numerator, denominator):
    try:
        result = numerator / denominator
        return result
    except ZeroDivisionError as e:
        print(f"Error: Cannot divide by zero! ({e})") # Handle ZeroDivisionError
        return None # Or return some default value, or re-raise the exception
```
---


# Handling Specific Exception Types using `try-except`

**Let's look at practical examples of using `try-except` blocks to handle specific types of exceptions.**

**Example 1: Handling `ZeroDivisionError`**

```py
# Example Usage:
num1 = 10
num2 = 0
result = divide_numbers(num1, num2) # This will cause ZeroDivisionError
if result is not None:
    print(f"The result of division is: {result}")

num3 = 20
num4 = 5
result2 = divide_numbers(num3, num4) # No error here
if result2 is not None:
    print(f"The result of division is: {result2}")
```
---

# Handling Specific Exception Types using `try-except`

**Let's look at practical examples of using `try-except` blocks to handle specific types of exceptions.**

**Example 1: Handling `ZeroDivisionError`**

**Explanation:**
- The `divide_numbers` function attempts division within a `try` block.
- If a `ZeroDivisionError` occurs during the division, the `except ZeroDivisionError as e:` block is executed.
- Inside the `except` block, we print an error message and return `None`.
- If no `ZeroDivisionError` occurs, the `except` block is skipped, and the `else` block (if present, not in this example) or the code after the try-`except` block would execute normally.
---

# Handling Specific Exception Types using `try-except`

**Let's look at practical examples of using `try-except` blocks to handle specific types of exceptions.**

**Example 2: Handling `FileNotFoundError`**
```py
def read_file_contents(file_path):
    try:
        with open(file_path, "r") as file:
            contents = file.read()
            return contents
    except FileNotFoundError:
        print(f"Error: File not found at path: '{file_path}'") # Handle FileNotFoundError
        return None

# Example Usage:
file_path1 = "my_document.txt" # Assuming this file might not exist
file_content1 = read_file_contents(file_path1)
if file_content1: # Check if content was successfully read (not None)
    print("File content:\n", file_content1)

file_path2 = "poem.txt" # Assuming poem.txt exists from previous exercise
file_content2 = read_file_contents(file_path2)
if file_content2:
    print("\nFile content (poem.txt):\n", file_content2)
```
---

# Handling Specific Exception Types using `try-except`

**Let's look at practical examples of using `try-except` blocks to handle specific types of exceptions.**

**Example 2: Handling `FileNotFoundError`**

**Explanation:**

- The `read_file_contents` function tries to open and read a file within a `try` block.
- If a `FileNotFoundError` occurs (if the file at `file_path` doesn't exist), the `except FileNotFoundError:` block is executed.
- We print an informative error message and return `None`.
- If the file is opened successfully, the code proceeds to read the content, and the `except` block is skipped.

**By handling specific exception types, you can create more targeted and informative error responses in your programs.**

**Next: Let's explore the else and finally blocks in try-except statements for more control! ‚û°Ô∏è**

---

### `try-except` - `else` and `finally` Blocks üõ†Ô∏è
# Expanding `try-except` -  `else` and `finally` Blocks
**The `try-except` structure can be further enhanced with optional `else` and `finally` blocks to provide more control over program flow.**

**1. `else` Block (Optional):**

*   **Executed if no exceptions in `try`:** The `else` block is executed *only if* the code in the `try` block completes successfully *without raising any exceptions*.
*   **Placement:** It comes *after* all `except` blocks (if any) and *before* the `finally` block (if present).
---

### `try-except` - `else` and `finally` Blocks üõ†Ô∏è
# Expanding `try-except` -  `else` and `finally` Blocks
**The `try-except` structure can be further enhanced with optional `else` and `finally` blocks to provide more control over program flow.**
**1. `else` Block (Optional):**

*   **Use case:** To put code that should run only when the "try" part is successful, keeping the `try` block focused solely on code that might raise exceptions.

    ```python
    def process_data(data):
        try:
            processed_result = perform_complex_operation(data) # Might raise ValueError, TypeError, etc.
        except ValueError as ve:
            print(f"ValueError during processing: {ve}")
            return None # Handle ValueError
        except TypeError as te:
            print(f"TypeError during processing: {te}")
            return None # Handle TypeError
        else: # Executed only if NO exceptions in 'try' block
            print("Data processing successful!")
            return processed_result # Return result if successful
        finally: # 'finally' block will also execute after 'else' if 'else' runs
            print("Data processing attempt finished.") # Always executed
    ```
---

### `try-except` - `else` and `finally` Blocks üõ†Ô∏è
# Expanding `try-except` -  `else` and `finally` Blocks
**The `try-except` structure can be further enhanced with optional `else` and `finally` blocks to provide more control over program flow.**
**1. `else` Block (Optional):**
* **Example usage:**
    ```py
    # Example usage:
    data1 = "valid data"
    result1 = process_data(data1) # 'else' block will likely execute if 'perform_complex_operation' works
    if result1:
        print("Result:", result1)

    data2 = "invalid data" # Might cause ValueError in 'perform_complex_operation'
    result2 = process_data(data2) # 'except ValueError' block will execute
    if result2 is None:
        print("Processing failed for data2.")
    ```
---

### `try-except` - `else` and `finally` Blocks üõ†Ô∏è
# Expanding `try-except` -  `else` and `finally` Blocks
**The `try-except` structure can be further enhanced with optional `else` and `finally` blocks to provide more control over program flow.**
**2. `finally` Block (Optional):**

*   **Always executed:** The `finally` block is executed *unconditionally*, regardless of whether an exception occurred in the `try` block, and whether the exception was caught or not.
*   **Placement:** It comes *last* in the `try-except` structure, after all `except` and the optional `else` block.
---

### `try-except` - `else` and `finally` Blocks üõ†Ô∏è
<!-- # Expanding `try-except` -  `else` and `finally` Blocks -->
<!-- **The `try-except` structure can be further enhanced with optional `else` and `finally` blocks to provide more control over program flow.** -->
*   **Use case:**  For essential **cleanup code** that must always run, such as:
    *   Logging completion status

    ```python
    file = None # Initialize file variable outside try block
    try:
        file = open("my_important_data.txt", "r") # Open file
        contents = file.read()
        process_contents(contents) # Process file data
        print("File processing successful.")
    except FileNotFoundError:
        print("Error: Input file not found!")
    except Exception as e: # Catch any other potential errors
        print(f"An unexpected error occurred: {e}")
    finally:
        if file: # Check if file was successfully opened
            file.close() # Ensure file is closed, even if errors occurred
            print("File (if opened) is now closed in 'finally' block.")
        else:
            print("File was not opened, so no need to close in 'finally'.")
        print("--- 'finally' block execution completed ---") # Always executed

    # Program continues after 'finally'
    ```
---

### `try-except` - `else` and `finally` Blocks üõ†Ô∏è
# Expanding `try-except` -  `else` and `finally` Blocks
**The `try-except` structure can be further enhanced with optional `else` and `finally` blocks to provide more control over program flow.**

**The `else` and `finally` blocks add flexibility and robustness to your exception handling, allowing you to manage different scenarios and ensure proper cleanup in your Python programs.**

**Next: Let's talk about deliberately raising exceptions in your own code!** ‚û°Ô∏è

---

## Raising Exceptions - The `raise` Statement üöÄ

# Raising Exceptions - Deliberately Triggering Errors

**Sometimes, you need to *deliberately* trigger or "raise" exceptions in your own code. This is useful in situations like:**

*   **Signaling error conditions:**  When your function or code detects an invalid input, an unexpected situation, or a condition that it cannot handle, raising an exception is a clear way to signal this error to the calling code.
*   **Enforcing constraints and preconditions:**  You can use exceptions to enforce rules or requirements for your code (e.g., input validation).
*   **Testing error handling:**  Raising exceptions allows you to test your `try-except` blocks and ensure your error handling logic works correctly.
---

### Raising Exceptions - The `raise` Statement üöÄ
# Raising Exceptions - Deliberately Triggering Errors

**The `raise` Statement:**

You use the `raise` statement to manually raise an exception in Python.

**Basic Syntax of `raise`:**

```python
raise ExceptionType("Error message")
```

- `raise` **keyword:** Signals that you want to raise an exception.
- `ExceptionType`**:** The type of exception you want to raise (e.g., `ValueError`, `TypeError`, `RuntimeError`, or a custom exception class).
- `("Error message")` **(optional):** An optional string argument that provides a descriptive error message associated with the exception. This message is often helpful for debugging.
---

## Raising Exceptions - The `raise` Statement üöÄ
**Examples of Raising Exceptions:**

**Example 1: Raising ValueError for invalid input:**

```py
def calculate_square_root(number):
    if number < 0:
        raise ValueError("Cannot calculate square root of a negative number.") # Raise ValueError
    return number ** 0.5

# Example Usage:
try:
    result1 = calculate_square_root(25)
    print(f"Square root of 25 is: {result1}")

    result2 = calculate_square_root(-9) # This will raise ValueError
    print(f"Square root of -9 is: {result2}") # This line will NOT be reached if ValueError is raised

except ValueError as e:
    print(f"Error: {e}") # Catch and handle the ValueError
```
---

## Raising Exceptions - The `raise` Statement üöÄ
**Examples of Raising Exceptions:**

**Example 2: Raising `TypeError` for incorrect data type:**

```py
def greet(name):
    if not isinstance(name, str): # Check if 'name' is a string
        raise TypeError("Argument 'name' must be a string.") # Raise TypeError
    return f"Hello, {name}!"

# Example Usage:
try:
    greeting1 = greet("Alice")
    print(greeting1)

    greeting2 = greet(123) # This will raise TypeError
    print(greeting2) # Not reached if TypeError is raised

except TypeError as e:
    print(f"Error: {e}") # Catch and handle the TypeError
```
---

## Raising Exceptions - The `raise` Statement üöÄ
**Examples of Raising Exceptions:**

**Example 3: Raising a generic `Exception` (less specific, use with care):**

```py
def process_item(item):
    if not item: # Check if item is None or empty
        raise Exception("Item cannot be empty or None.") # Raise a generic Exception
    # ... rest of processing logic ...
    print(f"Processing item: {item}")

# Example Usage:
try:
    process_item("data_item")
    process_item(None) # This will raise Exception
except Exception as e:
    print(f"Error during item processing: {e}") # Catch the generic Exception
```

**Using `raise` allows you to signal errors explicitly and control the error handling flow in your Python programs, making your code more robust and easier to debug.**

**Next: Let's learn about Assertions - another powerful tool for checking your code! ‚û°Ô∏è**

---

## Assertions - `assert` Statement for Checks ‚úÖ
# Using `assert` Statements for Internal Checks
**`assert` statements are a powerful tool in Python for performing internal sanity checks and debugging. They allow you to express conditions that you believe *must* be true at a certain point in your code.**

**Purpose of Assertions:**

*   **Verify assumptions:** Use `assert` to check if your assumptions about the state of your program (variable values, conditions) are actually holding true during execution.
*   **Detect logical errors early:** Assertions help you catch logical errors and unexpected conditions closer to their source, making debugging easier.
---

## Assertions - `assert` Statement for Checks ‚úÖ
# Using `assert` Statements for Internal Checks

**Purpose of Assertions:**

*   **For development and debugging, not for handling runtime errors:**  Assertions are primarily intended for use during development and testing. They are not meant to handle general runtime errors in production code (for that, use exceptions).
*   **Assertions can be disabled:** Assertions can be globally disabled at runtime (for performance in production), so you shouldn't rely on them for critical error handling logic in released software.
---

## Assertions - `assert` Statement for Checks ‚úÖ
# Using `assert` Statements for Internal Checks

### **Syntax of `assert` Statement:**

```python
assert condition, "Optional error message if condition is False"
```

- **assert keyword:** The keyword that starts an assertion statement.
- `condition`**:** Any Python expression that evaluates to a boolean value (True or False). This is the condition you are asserting to be true.
- **`", \"Optional error message if condition is False\""` (optional):** An optional second argument, which is a string. If the `condition` evaluates to `False`, an `AssertionError` is raised, and this string (if provided) will be included as part of the error message.
---

## Assertions - `assert` Statement for Checks ‚úÖ
# Using `assert` Statements for Internal Checks
### **How `assert` Works:**

- **Condition is True:** If the `condition` in the `assert` statement evaluates to `True`, **nothing happens,** and program execution continues to the next line.
- **Condition is False:** If the `condition` evaluates to `False`, an `AssertionError` **exception is raised**. The program execution typically stops at this point (unless the `AssertionError` is caught by a `try-except` block, which is generally not the intended use of assertions).
---

## Assertions - `assert` Statement for Checks ‚úÖ
# Using `assert` Statements for Internal Checks
**Examples of Using `assert`:**

**Example 1: Asserting input value validity:**
```py
def calculate_percentage(part, total):
    assert isinstance(part, (int, float)), "Argument 'part' must be a number" # Assert type
    assert isinstance(total, (int, float)), "Argument 'total' must be a number" # Assert type
    assert total > 0, "Argument 'total' must be greater than zero" # Assert condition
    if total == 0: # Redundant check AFTER assertion, for illustration (not needed after assertion)
        return 0 # Avoid division by zero (though assertion should prevent total=0 already)
    return (part / total) * 100

# Example Usage:
percentage1 = calculate_percentage(25, 100) # No assertion failure
print(f"Percentage 1: {percentage1}%")

percentage2 = calculate_percentage(60, 0) # Assertion 'total > 0' will fail - AssertionError
print(f"Percentage 2: {percentage2}%") # Will likely not be reached

percentage3 = calculate_percentage("abc", 100) # Assertion 'isinstance(part, (int, float))' will fail - AssertionError
print(percentage3) # Not reached
```
---

## Assertions - `assert` Statement for Checks ‚úÖ
# Using `assert` Statements for Internal Checks
**Examples of Using `assert`:**

**Example 2: Asserting expected program state:**

```py
def apply_discount(price, discount_percentage):
    assert 0 <= discount_percentage <= 100, "Discount percentage must be between 0 and 100"
    discount_amount = (discount_percentage / 100) * price
    discounted_price = price - discount_amount
    assert discounted_price <= price, "Discounted price should not be greater than original price!" # State assertion
    return discounted_price

# Example Usage:
final_price1 = apply_discount(100, 20) # No assertion failure
print(f"Final price 1: {final_price1}")

final_price2 = apply_discount(150, 120) # Assertion 'discount_percentage <= 100' will fail - AssertionError
print(final_price2) # Not reached
```
---

## Assertions - `assert` Statement for Checks ‚úÖ
# Using `assert` Statements for Internal Checks
**Examples of Using `assert`:**

**Assertions are a valuable tool for writing self-checking code and catching bugs early in the development process. Use them to validate your assumptions and make your code more robust and easier to debug during development!**

**Next: Let's briefly introduce Basic Type Annotations in Python! ‚û°Ô∏è**

---

### Basic Type Annotations - Introduction ‚å®Ô∏è
# Type Hints - Improving Code Readability

**Type annotations, also known as type hints, are a feature in Python that allows you to add optional type information to your code.**

**Key Points about Type Annotations:**

*   **Optional in Python:** Python is still a dynamically typed language. Type annotations are *hints*, not requirements. Python will run your code even if type annotations are incorrect or missing.
*   **For Readability and Static Analysis:** Type annotations are primarily for:
    *   **Improved code readability:** They make your code easier to understand by explicitly stating the expected types of variables, function arguments, and return values.
    *   **Static analysis tools (like MyPy):**  Type annotations enable static type checkers (like MyPy) to analyze your code *before* runtime and catch potential type-related errors early in development. This can help prevent bugs.
---

### Basic Type Annotations - Introduction ‚å®Ô∏è
# Type Hints - Improving Code Readability

**Type annotations, also known as type hints, are a feature in Python that allows you to add optional type information to your code.**

**Key Points about Type Annotations:**
*   **For Readability and Static Analysis:** (cntd.)
    *   **IDE and editor support:** Many modern IDEs and code editors use type annotations to provide better code completion, type checking, and refactoring assistance.
*   **No Runtime Enforcement by Standard Python:**  By default, Python interpreter does *not* enforce type annotations at runtime. If you violate a type hint, your code will still run (unless a static type checker like MyPy is used separately).
*   **Gradual Typing:** Python's type annotations allow for "gradual typing." You can add type hints to some parts of your code and leave other parts dynamically typed. You can gradually adopt type annotations in your codebase.
---
layout: two-cols-header
---

### Basic Type Annotations - Introduction ‚å®Ô∏è
# Type Hints - Improving Code Readability

**Type annotations, also known as type hints, are a feature in Python that allows you to add optional type information to your code.**

**Basic Syntax for Type Annotations:**
::left::
*   **Variable annotations:**
    ```python
    variable_name: type = value
    ```
    Example:
    ```python
    name: str = "Alice"
    age: int = 30
    price: float = 99.99
    is_active: bool = True
    ```
::right::
*   **Function annotations (for parameters and return type):**
    ```python
    def function_name(param1: type1, param2: type2) -> return_type:
        # Function body
        return value_of_return_type
    ```
    Example:
    ```python
    def greet_user(name: str) -> str:
        return f"Hello, {name}!"

    def add_numbers(x: int, y: int) -> int:
        return x + y
    ```
---
layout: two-cols
---

### Basic Type Annotations - Intro ‚å®Ô∏è
# Type Hints - Improving Code Readability

**Type annotations, also known as type hints, are a feature in Python that allows you to add optional type information to your code.**

**Commonly Used Built-in Types for Annotations:**

*   `int` (integer)
*   `float` (floating-point number)
*   `str` (string)
*   `bool` (boolean)
*   `list` (list)
::right::
*   `tuple` (tuple)
*   `dict` (dictionary)
*   `set` (set)
*   `None` (for variables that can be None)
*   `Any` (to indicate any type is allowed - use sparingly)

**Type annotations are a valuable tool for improving code clarity and maintainability, especially in larger projects. While they are optional in Python, adopting them can bring significant benefits to your development workflow!**

**Next: Let's see more examples of type annotations in functions and explore their benefits further!** ‚û°Ô∏è
---

### Type Annotations - Function Examples & Benefits ‚úçÔ∏è
# Type Annotations in Functions

**Let's explore more examples of type annotations specifically in functions and highlight the benefits they bring.**

**More Function Annotation Examples:**

**Example 1: Function with multiple arguments and return type:**

```python
def calculate_total_price(price: float, quantity: int, discount_rate: float) -> float:
    """Calculates the total price after discount."""
    discount_amount = price * quantity * discount_rate
    total_price = (price * quantity) - discount_amount
    return total_price

# Example calls:
total1: float = calculate_total_price(10.0, 5, 0.1) # Annotated return variable
print(f"Total price 1: ${total1:.2f}")

total2 = calculate_total_price(25.5, 2, 0.25) # Return type inferred (float)
print(f"Total price 2: ${total2:.2f}")
```
---

### Type Annotations - Function Examples & Benefits ‚úçÔ∏è
# Type Annotations in Functions

**Let's explore more examples of type annotations specifically in functions and highlight the benefits they bring.**

**More Function Annotation Examples:**

**Example 2: Function with list and optional argument:**
```py
from typing import List, Optional # Import 'List' and 'Optional' from 'typing' module

def process_names(names: List[str], prefix: Optional[str] = None) -> List[str]:
    """Adds a prefix to each name in a list (if prefix is provided)."""
    processed_names: List[str] = [] # Annotate list variable
    for name in names:
        if prefix:
            processed_names.append(f"{prefix} {name}")
        else:
            processed_names.append(name)
    return processed_names
```
---

### Type Annotations - Function Examples & Benefits ‚úçÔ∏è
# Type Annotations in Functions

**Let's explore more examples of type annotations specifically in functions and highlight the benefits they bring.**

**More Function Annotation Examples:**

**Example 2: Function with list and optional argument:**

```py
# Example calls:
names_list: List[str] = ["Alice", "Bob", "Charlie"] # Annotate list variable

processed_list1: List[str] = process_names(names_list) # No prefix
print("Processed names 1:", processed_list1)

processed_list2: List[str] = process_names(names_list, prefix="Dr.") # With prefix
print("Processed names 2:", processed_list2)
```
---

### Type Annotations - Function Examples & Benefits ‚úçÔ∏è
# Type Annotations in Functions

**Let's explore more examples of type annotations specifically in functions and highlight the benefits they bring.**

**More Function Annotation Examples:**

**Example 3: Function returning `None`:**

```py
def print_greeting(name: str) -> None: # Return type is explicitly None
    """Prints a greeting to the console (returns None)."""
    print(f"Greetings, {name}!")
    # No explicit return statement - implicitly returns None

result_none: None = print_greeting("Eve") # Annotated return variable as None
print("Return value:", result_none) # Will print: Return value: None
```
---

### Type Annotations - Function Examples & Benefits ‚úçÔ∏è
# Type Annotations in Functions

<!-- **Let's explore more examples of type annotations specifically in functions and highlight the benefits they bring.** -->

### **Benefits of Type Annotations (Recap & Expansion):**

- **Improved Code Readability and Understanding:** Types become explicit, making it easier to understand function signatures, variable usage, and data flow.
- **Early Error Detection (with Static Type Checkers):** Tools like MyPy can catch type-related errors *before you run your code*, reducing runtime bugs.
- **Enhanced IDE Support:** Type annotations enable IDEs to provide better code completion, suggestions, and refactoring capabilities, boosting development productivity.
- **Better Code Maintainability:** Type hints make it easier to modify and maintain code, especially in larger projects or when collaborating with others, as types are clearly documented in the code itself.
- **Documentation:** Type annotations serve as a form of documentation, clarifying the expected types for functions and variables.
---

### Type Annotations - Function Examples & Benefits ‚úçÔ∏è
# Type Annotations in Functions

**Type annotations are a valuable addition to modern Python development practices, contributing to more robust, readable, and maintainable code.  Consider adopting them in your projects!**

**Next: Let's do a final "Your Turn" exercise for Session 7, incorporating Error Handling, Assertions, and Type Annotations! ‚û°Ô∏è**

---

## Your Turn: Error Handling Exercise ‚úçÔ∏è

# Practice `try-except` & `assert`

<!-- **Time to put your error handling skills into practice!** -->

### **Exercise 1: Handling `ValueError` and `TypeError`**

1.  **Write a Python function called `safe_int_input(prompt)` that does the following:**
    *   Takes a `prompt` string as input (to display to the user).
    *   Uses the `input()` function to get user input as a string.
    *   **Attempts to convert the user input to an integer using `int()`.**
    *   **Handles potential `ValueError`:** If the user input is not a valid integer, catch the `ValueError` exception, print an informative error message (e.g., "Invalid input. Please enter an integer."), and return `None`.
    *   **Handles potential `TypeError`**: Although less likely with `input()` and `int()`, consider if `TypeError` could occur in your approach and handle it gracefully (print error, return `None`).
    *   **If the conversion to integer is successful, return the integer value.**
---

## Your Turn: Error Handling Exercise ‚úçÔ∏è

# Practice `try-except` & `assert`
### **Exercise 1: Handling `ValueError` and `TypeError`**

2.  **Write a main part of your script that:**
    *   Calls `safe_int_input("Enter your age: ")` to get the user's age.
    *   Calls `safe_int_input("Enter a number for calculation: ")` to get another number.
    *   **Checks if both inputs are valid integers (i.e., not `None`).**
    *   If both are valid integers, perform a calculation (e.g., sum, difference, etc.) and print the result.
    *   If either input is `None` (meaning invalid input was given), print a message indicating that the calculation cannot be performed due to invalid input.
---

## Your Turn: Error Handling Exercise ‚úçÔ∏è
# Practice `try-except` & `assert`

### **Exercise 2: Using `assert` for input validation**

1.  **Write a Python function `calculate_discounted_price(price, discount_percentage)` that:**
    *   Takes `price` and `discount_percentage` as input.
    *   **Uses `assert` statements to validate the inputs:**
        *   Assert that `price` is a positive number (greater than 0).
        *   Assert that `discount_percentage` is between 0 and 100 (inclusive).
        *   Include informative error messages in your `assert` statements to explain the validation rules.
    *   **If the assertions pass (inputs are valid), calculate and return the discounted price.**
    *   **If any assertion fails, an `AssertionError` will be raised (which is the expected behavior for input validation using `assert`).**
---

## Your Turn: Error Handling Exercise ‚úçÔ∏è
# Practice `try-except` & `assert`

### **Exercise 2: Using `assert` for input validation**

2.  **Write a main part of your script to test `calculate_discounted_price` with both valid and invalid inputs to see the assertions in action.**


**Complete these exercises in your Jupyter Notebook to solidify your understanding of `try-except` blocks for error handling and `assert` statements for input validation and debugging! üöÄ**

**Next: We are almost at the summary of Session 7. Just one more topic to cover - Basic Type Annotations in exercises! ‚û°Ô∏è**

---

### Your Turn: Type Annotations Exercise ‚úçÔ∏è

# Your Turn! Type Annotations Exercise - Add Type Hints to Functions

<!-- **Let's practice adding basic type annotations to Python functions to improve code readability and prepare for static type checking!** -->

### **Exercise: Add Type Annotations to Functions**

1.  **Take the following Python functions (which are currently *without* type annotations):**

    ```python
    def calculate_average(numbers):
        total = sum(numbers)
        average = total / len(numbers)
        return average

    def get_greeting_message(name, is_formal):
        if is_formal:
            return f"Good day, Mr./Ms. {name}."
        else:
            return f"Hello, {name}!"

    def filter_even_numbers(number_list):
        even_numbers = [num for num in number_list if num % 2 == 0]
        return even_numbers
    ```
---

### Your Turn: Type Annotations Exercise ‚úçÔ∏è

<!-- # Your Turn! Type Annotations Exercise - Add Type Hints to Functions -->

<!-- **Let's practice adding basic type annotations to Python functions to improve code readability and prepare for static type checking!** -->

### **Exercise: Add Type Annotations to Functions**

2.  **For each function, add type annotations to:**
    *   Function parameters (specify the expected type for each parameter).
    *   Function return value (specify the type of value the function is expected to return).
    *   For `calculate_average`, assume `numbers` should be a list of numbers (either `List[int]` or `List[float]`, or `List[Union[int, float]]` from `typing` if you want to allow both).  Return type should be `float`.
    *   For `get_greeting_message`, `name` should be a string (`str`), `is_formal` should be a boolean (`bool`), and the return type should be a string (`str`).
    *   For `filter_even_numbers`, `number_list` should be a list of integers (`List[int]`), and the return type should also be a list of integers (`List[int]`).  Remember to import `List` and `Union` (if used) from the `typing` module.
---

### Your Turn: Type Annotations Exercise ‚úçÔ∏è

# Your Turn! Type Annotations Exercise - Add Type Hints to Functions

<!-- **Let's practice adding basic type annotations to Python functions to improve code readability and prepare for static type checking!** -->

### **Exercise: Add Type Annotations to Functions**

3.  **Write example calls to each function *both with and without* assigning the returned value to a *type-annotated variable*.**  For example:

    ```python
    # Example calls (after adding type annotations to functions)

    # 1. calculate_average
    number_data = [10, 20, 30, 40]
    avg_result: float = calculate_average(number_data) # Annotated variable
    print("Average:", avg_result)
    average_value = calculate_average([5, 10, 15]) # No annotation on variable - still valid
    print("Average value:", average_value)


    # ... (Add similar example calls for get_greeting_message and filter_even_numbers,
    #      with and without annotated variables for return values) ...
    ```
---

### Your Turn: Type Annotations Exercise ‚úçÔ∏è

# Your Turn! Type Annotations Exercise - Add Type Hints to Functions

<!-- **Let's practice adding basic type annotations to Python functions to improve code readability and prepare for static type checking!** -->

### **Exercise: Add Type Annotations to Functions**
4.  **(Optional but Recommended):** If you have MyPy set up, run MyPy on your code to see if it detects any type-related issues or if your type annotations are considered valid.

**This exercise will give you practical experience in adding basic type annotations to functions and understanding how they improve code clarity!** üöÄ

```python
# Your Python code with Type Annotations for the Exercise goes here:
```

**Next: Let's wrap up Session 7 with a summary of what we've learned about Error Handling, Assertions, and Type Annotations! ‚û°Ô∏è**

---

### Session 7 Summary - Error Handling, Assertions & Types ‚úÖ
# Session 7 Wrap-up: Error Handling, Assertions & Type Annotations

**Congratulations on completing Session 7!** üéâ You've significantly enhanced your Python programming toolkit in this session by learning about:

**1. Error Handling with Exceptions (`try-except`):**

*   **Purpose:** To handle runtime errors gracefully and prevent program crashes.
*   **`try-except` blocks:**  How to catch and handle exceptions.
*   **Specific Exception Types:** Handling different error types (`ValueError`, `FileNotFoundError`, etc.).
*   **`else` and `finally` blocks:** For more control in exception handling.
*   **Raising Exceptions (`raise`):**  Deliberately triggering exceptions to signal errors.
---

### Session 7 Summary - Error Handling, Assertions & Types ‚úÖ
# Session 7 Wrap-up: Error Handling, Assertions & Type Annotations

**Congratulations on completing Session 7!** üéâ You've significantly enhanced your Python programming toolkit in this session by learning about:

**2. Assertions (`assert` statements):**

*   **Purpose:**  For internal program checks, verifying assumptions, and debugging.
*   **`assert condition, "Error Message"`:**  Syntax for writing assertions.
*   **Assertions for development/debugging:** Not for general runtime error handling in production.
---

### Session 7 Summary - Error Handling, Assertions & Types ‚úÖ
# Session 7 Wrap-up: Error Handling, Assertions & Type Annotations

**Congratulations on completing Session 7!** üéâ You've significantly enhanced your Python programming toolkit in this session by learning about:

**3. Basic Type Annotations (Type Hints):**

*   **Purpose:** To improve code readability, enable static analysis, and enhance IDE support.
*   **Optional in Python:**  Hints, not runtime requirements.
*   **Syntax for variable and function annotations:**  `variable: type = value`, `def func(param: type) -> return_type:`.
*   **Benefits:** Readability, early error detection (MyPy), IDE assistance, maintainability.
---

### Session 7 Summary - Error Handling, Assertions & Types ‚úÖ
# Session 7 Wrap-up: Error Handling, Assertions & Type Annotations

### **Key Takeaway from Session 7:**

*   You are now equipped to write more robust and reliable Python code by handling potential errors using exceptions.
*   You can use assertions to build self-checking code and catch logical errors during development.
*   You have a basic understanding of type annotations and how they can improve your code's clarity and maintainability.

**These are essential skills for writing professional-quality Python code!** üí™

**Next: That's the end of Session 7! Let's officially conclude this session on the next slide!** ‚û°Ô∏è

---

### Session 7 - Session End üéâ

# Session 7 Complete! Error Handling, Assertions & Type Annotations ‚úÖ

**You have reached the end of Session 7: "Error Handling - Exceptions, Assertions, and Basic Type Annotations"!**

**Fantastic work!** You've added crucial error handling and code quality tools to your Python skillset in this session.
---

### Session 7 - Session End üéâ

<!-- # Session 7 Complete! Error Handling, Assertions & Type Annotations ‚úÖ -->

**Key achievements in Session 7:**

*   You understand the importance of error handling for robust programs.
*   You can use `try-except` blocks to gracefully handle runtime exceptions and prevent crashes.
*   You know how to handle specific exception types for targeted error responses.
*   You can use `else` and `finally` blocks for more advanced exception handling control.
*   You can deliberately raise exceptions using `raise` to signal error conditions.
*   You can use `assert` statements for internal code checks and debugging during development.
*   You have a basic understanding of type annotations and how they improve code readability and maintainability.

**You are now well-equipped to write more reliable, easier-to-debug, and more professional Python code!**

**Ready to move on to the next session?**

**Up Next: Session 8 - Advanced Topics - Iterators, Generators & Decorators** üöÄ