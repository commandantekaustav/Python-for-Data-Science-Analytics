---
transition: slide-left
align: centre
title: Introduction to OOP & File Handling


layout: section
---

# Session 6: 
## Introduction to Object-Oriented Programming (OOP) & File Handling
---

## Session 6 - Welcome to OOP & File Handling! üöÄ

**Welcome to Session 6!**  This session is a *combined* session where we will begin exploring two important and somewhat distinct topics:

1.  **Introduction to Object-Oriented Programming (OOP):**  We'll start our journey into OOP, a powerful programming paradigm that helps you structure and organize larger programs in a more intuitive and manageable way.  We will cover the fundamental concepts of OOP.

2.  **File Handling: Input and Output:** We will also learn how to work with files in Python, allowing your programs to read data from files and write data to files. This is essential for interacting with external data and making your programs more practical.

**We will aim to cover the essential introductory aspects of both OOP and File Handling in this session.**
---
layout: two-cols-header
---

## Session 6 - Welcome to OOP & File Handling! üöÄ

**In this combined Session 6, we will touch upon:**
::left::
*   **(OOP - Introduction):**
    *   What is Object-Oriented Programming (OOP)?  Why use OOP?
    *   Classes and Objects - the fundamental building blocks of OOP.
    *   Attributes and Methods - data and actions associated with objects.
    *   Basic OOP principles (Encapsulation, Abstraction - time permitting).
::right::
*   **(File Handling):**
    *   Basic File Input and Output (I/O) operations.
    *   Opening files, reading file content, writing to files.
    *   File modes (read, write, append).
    *   Using `with open(...)` for file handling.
    *   Working with text files.

**This session will give you a first taste of Object-Oriented Programming and equip you with essential skills for working with files in Python!**

**Let's start with the Introduction to Object-Oriented Programming!** ‚û°Ô∏è

---

### Object-Oriented Programming (OOP)?
# What is Object-Oriented Programming (OOP)? ü§î
<br>

**Object-Oriented Programming (OOP) is a powerful programming *paradigm* (a style or way of programming). It's a different way of thinking about and structuring your code compared to what we've done so far.**
---
layout: two-cols
---

### Object-Oriented Programming (OOP)?
# What is Object-Oriented Programming (OOP)? ü§î

**Traditional Programming (Procedural):**

*   **Focus on functions and procedures (steps).**  Programs are seen as a sequence of instructions (functions) that operate on data.
*   **Data and functions are separate.** Data is often stored in variables, and functions are defined to manipulate this data.
*   **Example (Analogy):**  Think of a recipe (procedural). You have ingredients (data), and you follow a series of steps (functions) to transform the ingredients into a dish.
::right::
**Object-Oriented Programming (OOP):**

*   **Focus on "objects."** Programs are designed around "objects," which are self-contained units that combine both data and functions that operate on that data.
*   **Data and functions are bundled together.**  Data (attributes) and functions (methods) that operate on that data are grouped together within an object.
*   **Example (Analogy):** Think of building with LEGO bricks (OOP).  Each LEGO brick (object) has its own properties (color, shape - data) and can perform actions or connect to other bricks (methods). You build larger structures by combining and interacting with these objects.
---

### Object-Oriented Programming (OOP)?
# What is Object-Oriented Programming (OOP)? ü§î
<br>

**Key Idea of OOP:  Organize code around "objects" that represent real-world entities or concepts.**

**Why use OOP?  Let's explore the benefits on the next slide!** ‚û°Ô∏è

---

## Why Use Object-Oriented Programming (OOP)? ü§î

# Object-Oriented Programming - The Advantages

**OOP is not just another way to program; it offers significant advantages, especially for larger and more complex projects.**

**Key Benefits of OOP:**

**1. Modularity and Organization:**

*   **Breaks down complex systems:** OOP helps you decompose complex problems into smaller, self-contained, and manageable units (objects and classes).
*   **Improved code structure:**  Organizes code in a more logical and intuitive way, mirroring real-world entities and their interactions.
*   **Easier to navigate and understand:**  Makes large codebases easier to browse, comprehend, and maintain because code is grouped by object rather than being scattered in procedural code.
---

## Why Use Object-Oriented Programming (OOP)? ü§î

# Object-Oriented Programming - The Advantages

**OOP is not just another way to program; it offers significant advantages, especially for larger and more complex projects.**

**Key Benefits of OOP:**

**2. Reusability (Code Reuse):**

*   **Classes as blueprints:**  Classes act as templates for creating objects. Once you define a class, you can create multiple objects (instances) of that class, reusing the same structure and behavior.
*   **Inheritance (a key OOP concept):**  OOP allows you to create new classes that inherit properties and behaviors from existing classes, promoting code reuse and reducing redundancy (we may touch on this briefly later).
---

## Why Use Object-Oriented Programming (OOP)? ü§î

# Object-Oriented Programming - The Advantages

**OOP is not just another way to program; it offers significant advantages, especially for larger and more complex projects.**

**Key Benefits of OOP:**

**3. Encapsulation (Data Hiding):**

*   **Bundling data and methods:**  OOP encapsulates data (attributes) and the functions that operate on that data (methods) within objects.
*   **Data protection:**  Encapsulation can help protect an object's internal data from accidental modification from outside, leading to more robust and reliable code.

---

## Why Use Object-Oriented Programming (OOP)? ü§î

# Object-Oriented Programming - The Advantages

**OOP is not just another way to program; it offers significant advantages, especially for larger and more complex projects.**

**Key Benefits of OOP:**

**4. Abstraction (Simplifying Complexity):**

*   **Focus on essential features:** OOP allows you to hide complex implementation details and expose only the necessary information and functionalities through a simplified interface (abstraction).
*   **Easier to use objects:** Users of an object interact with it through its well-defined methods without needing to know the intricate internal workings.
---

## Why Use Object-Oriented Programming (OOP)? ü§î

# Object-Oriented Programming - The Advantages

**OOP is not just another way to program; it offers significant advantages, especially for larger and more complex projects.**

**Key Benefits of OOP:**

**5. Maintainability and Scalability:**

*   **Easier to modify and extend:**  Due to modularity and encapsulation, OOP code tends to be easier to modify, update, and extend as project requirements evolve.
*   **Better for teamwork:**  OOP facilitates collaboration among developers because objects provide well-defined interfaces and responsibilities, making it easier to divide work and integrate code.

**OOP is a powerful paradigm that is widely used in building modern software applications, especially large-scale and complex systems.**

**Next: Let's get to the core building blocks of OOP: Classes and Objects!** ‚û°Ô∏è

---

### Classes and Objects - The Building Blocks üß±
# Classes and Objects: The Core of OOP

**In Object-Oriented Programming, everything revolves around **classes** and **objects**. These are the fundamental building blocks.**

**1. Class:**

*   **Blueprint or Template:** A class is like a blueprint, a template, or a cookie cutter. It defines the *structure* and *behavior* for a type of object.
*   **Description of objects:** It describes what kind of data (attributes) and actions (methods) objects of that class will have.
*   **Not an object itself:** A class is not an object itself. It's just a definition or a plan.
*   **Analogy:** Think of a cookie cutter (the class). It's a mold that defines the shape of a cookie, but it's not a cookie itself.
---

### Classes and Objects - The Building Blocks üß±
# Classes and Objects: The Core of OOP

**In Object-Oriented Programming, everything revolves around **classes** and **objects**. These are the fundamental building blocks.**

**2. Object (Instance):**

*   **Instance of a class:** An object is a specific *instance* created from a class. It's a concrete realization of the blueprint defined by the class.
*   **Real-world entity:** Objects represent real-world entities or concepts in your program (e.g., a car, a user, a bank account).
*   **Has attributes and methods:** Each object has its own set of data (attributes, specific to that object) and can perform actions (methods, defined by its class).
*   **Analogy:** Think of a cookie (the object). It's created using the cookie cutter (the class). Each cookie is a separate instance, and they all share the same basic shape defined by the cutter, but they are individual cookies.
---

### Classes and Objects - The Building Blocks üß±
# Classes and Objects: The Core of OOP

<!-- **In Object-Oriented Programming, everything revolves around **classes** and **objects**. These are the fundamental building blocks.** -->

**Relationship:  Class is the *type*, Object is a *specific instance* of that type.**

**Example (Conceptual):**

*   **Class:**  `Car` (blueprint for what a car is)
    *   **Attributes (Data):** `color`, `model`, `engine_type`, `number_of_doors` (common properties of cars)
    *   **Methods (Actions):** `start_engine()`, `accelerate()`, `brake()`, `honk()` (actions a car can perform)

*   **Objects (Instances of the Car class):**
    *   `my_car` (a specific car object - e.g., color: "red", model: "Sedan")
    *   `another_car` (another car object - e.g., color: "blue", model: "SUV")

**Next: Let's see how to *define* classes and create *objects* in Python code!** ‚û°Ô∏è

---

### Defining Classes in Python - `class` Keyword ‚úçÔ∏è
# Defining Classes : Creating Blueprints for Objects

**To create your own classes (blueprints for objects) in Python, you use the `class` keyword.**

**Basic Syntax for Defining a Class:**

```python
class ClassName:
    """Docstring: Briefly describe what the class represents."""
    # Class attributes (optional - data shared by all objects of this class)
    class_attribute = value
    # Constructor (__init__ method) - special method to initialize objects (instances)
    def __init__(self, attribute1_value, attribute2_value, ...):
        """Initializes a new object of the class."""
        self.attribute1 = attribute1_value   # Instance attributes (specific to each object)
        self.attribute2 = attribute2_value
        # ... more attribute initializations ...
    # Methods (functions that objects of this class can perform)
    def method_name(self, parameter1, parameter2, ...):
        """Describes what this method does."""
        # Method body - code to define the action/behavior
        # ... method statements ...
        return some_value # Optional: method can return a value
    # ... more methods can be defined ...
```
---

### Defining Classes in Python - `class` Keyword ‚úçÔ∏è
# Defining Classes : Creating Blueprints for Objects

**Let's break down the key parts of a class definition:**

- **`class` keyword:** Signals the start of a class definition.
- `ClassName`: You choose a name for your class.
    - **Convention:** Use `CapitalizedWords` (PascalCase) for class names (e.g., `Car`, `BankAccount`, `UserProfile`).
- **Colon `:`:** Required at the end of the `class ClassName:` line, indicating the start of the class's code block.
- **Docstring (optional, but recommended):** A string in triple quotes `"""Docstring goes here"""` right after the class definition line, describing the purpose of the class.
- **Class Attributes (optional):** Variables defined directly within the class (not inside `__init__` or other methods). These are shared by all objects of the class (less common in basic OOP).
---

### Defining Classes in Python - `class` Keyword ‚úçÔ∏è
# Defining Classes : Creating Blueprints for Objects

**Let's break down the key parts of a class definition:**

- **Constructor (`__init__` method):**
    - **Special method name:** `__init__` (double underscores before and after) is a reserved name in Python for the constructor.
    - **Called when an object is created:** The `__init__` method is automatically called when you create a new object (instance) of the class.
    - `self` **parameter (mandatory):** The first parameter of `__init__` (and most methods) is always `self`. `self` refers to the instance of the object being created or operated upon.
    - **Initialize instance attributes:** Inside `__init__`, you typically use `self.attribute_name = value` to create and initialize instance attributes (attributes specific to each object).

---

### Defining Classes in Python - `class` Keyword ‚úçÔ∏è
# Defining Classes : Creating Blueprints for Objects
**Let's break down the key parts of a class definition:**


- **Methods (Functions inside the class):**
- **Functions defined within the class block** are called methods. They define the actions that objects of this class can perform.
- **`self` parameter (mandatory for most methods):** The first parameter of almost all methods is `self`, which provides access to the object's attributes and other methods within the class.

**Next: Let's see a concrete example of defining a simple class in Python! ‚û°Ô∏è**

---

### Defining a Class - Example: `Dog` Class üêï
<!-- # Defining a Class - Concrete Example: The `Dog` Class -->
**Let's define a simple class called `Dog` to illustrate class definition in Python.**

<!-- **Example - Defining the `Dog` Class:** -->

```python
class Dog:
    """A simple class representing a dog."""

    def __init__(self, name, breed, age):
        """
        Initializes a Dog object with name, breed, and age.
        These are instance attributes specific to each Dog object.
        """
        self.name = name      # Instance attribute: dog's name
        self.breed = breed    # Instance attribute: dog's breed
        self.age = age        # Instance attribute: dog's age
        print(f"Dog object created: {self.name} the {self.breed}") # Just for demonstration

    def bark(self):
        """Simulates a dog barking."""
        print("Woof! Woof!")

    def describe(self):
        """Describes the dog's attributes."""
        print(f"{self.name} is a {self.age}-year-old {self.breed}.")
```
---

### Defining a Class - Example: `Dog` Class üêï
**Explanation of the `Dog` Class:**

- **`class Dog:`:** Starts the class definition for a class named `Dog`.
- **Docstring:** `"""A simple class representing a dog."""` - Describes the purpose of the `Dog` class.
- `__init__(self, name, breed, age):` **- Constructor:**
    - This `__init__` method is the constructor. It's called when you create a `Dog` object.
    - It takes `self`, `name`, `breed`, and `age` as parameters.
    - Inside `__init__`:
        - `self.name = name`: Creates an *instance attribute* called `name` and assigns it the `name` argument value.
        - `self.breed = breed`: Creates an *instance attribute* called `breed` and assigns it the `breed` argument value.
        - `self.age = age`: Creates an *instance attribute* called `age` and assigns it the `age` argument value.
    - `print(...)`: Just a demonstration to show when a `Dog` object is created.
---

### Defining a Class - Example: `Dog` Class üêï
**Explanation of the `Dog` Class (cntd.):**

- `bark(self):`** - Method:**
    - Defines a method called `bark`. Methods are functions associated with the class.
    - It takes `self` as the parameter (essential for methods to access object's attributes).
    - It simply prints "Woof! Woof!".
- `describe(self):` **- Method:**
    - Defines another method called `describe`.
    - It uses `self.name`, `self.age`, and `self.breed` (instance attributes) to print a description of the dog.
    
**Now that we've defined the `Dog` class (the blueprint), let's learn how to create *objects* (instances) of this class! ‚û°Ô∏è**

---

### Creating Objects (Instances) of a Class üê∂
# Creating Objects (Instances) from a Class

**Once you have defined a class, you can create individual **objects** (instances) of that class.**

**How to Create an Object (Instantiation):**

To create an object, you "call" the class name like a function, passing arguments to the class's `__init__` method (constructor) if it expects any.

**Syntax for Object Creation:**

```python
object_name = ClassName(argument1, argument2, ...)
```

- **`object_name`:** You choose a name for your object (variable to hold the object).
- **`ClassName`:** The name of the class you want to create an object of (e.g., `Dog`).
- **`()` `Parentheses`:** Required to call the class like a function.
- **`arguments` (optional):** Arguments you pass inside the parentheses are sent to the `__init__` method of the class to initialize the object's attributes.
---

### Creating Objects (Instances) of a Class üê∂
# Creating Objects (Instances) from a Class

**Once you have defined a class, you can create individual **objects** (instances) of that class.**

**Example - Creating `Dog` objects:**
```py
# Creating Dog objects (instances of the Dog class):
my_dog = Dog("Buddy", "Golden Retriever", 3) # Create a Dog object and assign it to my_dog
another_dog = Dog("Lucy", "Poodle", 5)      # Create another Dog object and assign it to another_dog

# Output (from the __init__ method's print statements in the Dog class definition):
# Dog object created: Buddy the Golden Retriever
# Dog object created: Lucy the Poodle


# Now, my_dog and another_dog are individual Dog objects (instances)
# Each has its own set of attributes (name, breed, age) as initialized in __init__
```
---

<!-- ### Creating Objects (Instances) of a Class üê∂ -->
# Creating Objects (Instances) from a Class

**Once you have defined a class, you can create individual **objects** (instances) of that class.**

**Explanation:**

1.  `. my_dog = Dog("Buddy", "Golden Retriever", 3)`:
- `Dog("Buddy", "Golden Retriever", 3)` is the object creation part. It calls the `Dog` class.
- Arguments `"Buddy"`, `"Golden Retriever"`, and `3` are passed to the `__init__` method.
- The `__init__` method then initializes the `name`, `breed`, and `age` attributes of the *new* `Dog` object being created.
- The newly created `Dog` object is then assigned to the variable `my_dog`.

2. a`nother_dog = Dog("Lucy", "Poodle", 5)`: Does the same process, creating another separate `Dog` object and assigning it to `another_dog`.

**Each object is a distinct instance of the class, with its own unique set of attribute values!**

**Next: Let's see how to access the attributes and call the methods of these objects! ‚û°Ô∏è**
---

### Accessing Attributes and Calling Methods üêæ
# Accessing Attributes and Calling Methods of Objects
**Once you have created objects (instances) of a class, you can interact with them by:**

1.  **Accessing their attributes (data):**  Getting or setting the values of an object's attributes.
2.  **Calling their methods (actions):**  Instructing an object to perform actions defined by its class.

**Dot Notation (`.`): The Key to Accessing Object Members**

Python uses **dot notation** (`.`) to access both attributes and methods of an object.

**1. Accessing Attributes:**

```python
object_name.attribute_name
```

- `object_name`: The variable holding the object (e.g., `my_dog`, `another_dog`).
- `.` **(dot operator):** Used to access members of the object.
- `attribute_name`*:* The name of the attribute you want to access (e.g., `name`, `breed`, `age`).
---

### Accessing Attributes and Calling Methods üêæ
# Accessing Attributes and Calling Methods of Objects
<br>

**Example - Accessing `Dog` object attributes:**

```py
my_dog = Dog("Buddy", "Golden Retriever", 3) # Create a Dog object

print(my_dog.name)  # Access the 'name' attribute of my_dog
# Output: Buddy

print(my_dog.breed) # Access the 'breed' attribute
# Output: Golden Retriever

print(my_dog.age)   # Access the 'age' attribute
# Output: 3
```
---

### Accessing Attributes and Calling Methods üêæ
# Accessing Attributes and Calling Methods of Objects
<br>

**2. Calling Methods:**

```py
object_name.method_name(arguments_for_method)
```

- `object_name`: The object whose method you want to call.
- `.` **(dot operator):** Again, used to access object members.
- `method_name`: The name of the method you want to call (e.g., `bark`, `describe`).
- `()` **Parentheses:** Needed to call the method (just like calling a regular function).
- `arguments_for_method` **(optional):** If the method definition includes parameters (other than self), you pass arguments here.
---

### Accessing Attributes and Calling Methods üêæ
# Accessing Attributes and Calling Methods of Objects
<br>

**Example - Calling `Dog` object methods:**

```py
my_dog = Dog("Buddy", "Golden Retriever", 3) # Create a Dog object

my_dog.bark()  # Call the 'bark' method of my_dog
# Output: Woof! Woof!

my_dog.describe() # Call the 'describe' method
# Output: Buddy is a 3-year-old Golden Retriever.
```

**Dot notation is fundamental to working with objects in Python. It allows you to interact with objects, access their data, and make them perform actions!**

**Next: Let's do a "Your Turn" exercise to practice creating objects and interacting with them! ‚û°Ô∏è**

---

### Class and Object Exercise ‚úçÔ∏è
# Your Turn! Class and Object Exercise - `Rectangle` Class
**Time to practice defining a class and creating objects!**

**Exercise: Design a `Rectangle` Class**

**Task:**  Create a Python class named `Rectangle` that represents a rectangle.

**The `Rectangle` class should have:**

1.  **Constructor (`__init__` method):**
    *   It should take two parameters (besides `self`): `length` and `width`.
    *   It should initialize two instance attributes:
        *   `self.length` (assigned the value of the `length` parameter)
        *   `self.width` (assigned the value of the `width` parameter)
---

### Class and Object Exercise ‚úçÔ∏è
# Your Turn! Class and Object Exercise - `Rectangle` Class
**Time to practice defining a class and creating objects!**

**The `Rectangle` class should have:**

2.  **Method `calculate_area(self)`:**
    *   It should calculate the area of the rectangle (length * width).
    *   It should **return** the calculated area.

3.  **Method `calculate_perimeter(self)`:**
    *   It should calculate the perimeter of the rectangle (`2 * (length + width)`).
    *   It should **return** the calculated perimeter.
---

### Class and Object Exercise ‚úçÔ∏è
# Your Turn! Class and Object Exercise - `Rectangle` Class
**Time to practice defining a class and creating objects!**

**The `Rectangle` class should have:**

4.  **Method `describe(self)`:**
    *   It should print a description of the rectangle, including its length, width, area, and perimeter.  For example:
        ```
        Rectangle description:
        Length: 5
        Width: 10
        Area: 50
        Perimeter: 30
        ```
---

### Class and Object Exercise ‚úçÔ∏è
# Your Turn! Class and Object Exercise - `Rectangle` Class

## **After defining the `Rectangle` class:**

1.  Create **two `Rectangle` objects** with different lengths and widths (e.g., `rectangle1` with length 5, width 10; and `rectangle2` with length 8, width 4).
2.  For **each `Rectangle` object**:
    *   Call the `calculate_area()` method and print the returned area.
    *   Call the `calculate_perimeter()` method and print the returned perimeter.
    *   Call the `describe()` method to print the rectangle's description.

**Work through this exercise in your Jupyter Notebook. This will solidify your understanding of classes and objects! üöÄ**

**Next: We will briefly touch upon the OOP principles of Encapsulation and Abstraction! ‚û°Ô∏è**

---

### OOP Principles ‚öôÔ∏è
# OOP Principles: Encapsulation and Abstraction
**Encapsulation and Abstraction are two fundamental principles in Object-Oriented Programming that contribute to good code design.**

**1. Encapsulation:**

*   **Bundling Data and Methods:** Encapsulation means bundling the data (attributes) and methods (actions) that operate on that data *within a single unit* (an object/class).
*   **Information Hiding:** It also often involves hiding the internal implementation details of an object and exposing only a controlled interface to interact with it.
*   **Analogy:** Think of a car engine.  The complex inner workings of the engine (data and processes) are encapsulated within the engine unit. You interact with the engine through well-defined interfaces like the accelerator pedal (methods), without needing to know all the internal combustion details.
---

### OOP Principles ‚öôÔ∏è
# OOP Principles: Encapsulation and Abstraction
**Encapsulation and Abstraction are two fundamental principles in Object-Oriented Programming that contribute to good code design.**


**Benefits of Encapsulation:**

*   **Data Protection:** Prevents accidental or unauthorized modification of an object's internal data.
*   **Modularity:** Makes objects self-contained and independent, reducing dependencies and making code easier to manage.
*   **Maintainability:** Changes to the internal implementation of an object are less likely to affect other parts of the program, as long as the public interface remains consistent.
---

### OOP Principles ‚öôÔ∏è
# OOP Principles: Encapsulation and Abstraction
**Encapsulation and Abstraction are two fundamental principles in Object-Oriented Programming that contribute to good code design.**

**2. Abstraction:**

*   **Simplifying Complexity:** Abstraction means hiding complex implementation details and presenting only the essential information and functionalities to the user.
*   **Focus on "what" not "how":**  Users interact with objects through simplified, high-level interfaces without needing to know the "how" behind the operations.
*   **Analogy:** Think of a TV remote control. It provides a simple, abstract interface (buttons) to control a complex device (the TV). You don't need to understand the electronics inside the TV or remote to change the channel or volume.
---

### OOP Principles ‚öôÔ∏è
# OOP Principles: Encapsulation and Abstraction
**Encapsulation and Abstraction are two fundamental principles in Object-Oriented Programming that contribute to good code design.**

**Benefits of Abstraction:**

*   **Simplified Usage:** Makes objects easier to use and understand, as users don't get bogged down in unnecessary details.
*   **Reduced Complexity:**  Helps manage complexity by allowing you to focus on the essential aspects of an object and its interactions.
*   **Flexibility:** Allows you to change the internal implementation of an object without affecting how users interact with it (as long as the abstract interface remains the same).

**Encapsulation and Abstraction are key to writing well-structured, robust, and maintainable OOP code. They help manage complexity and promote good design principles.**

**Next:  We are now transitioning to the second topic of this session: File Handling!** ‚û°Ô∏è

---

### Introduction to File Handling üìÇ
# Introduction to File Handling in Python
**Now, let's shift gears and move on to the second major topic of this session: **File Handling** in Python.**

**What is File Handling?**

*   **Interacting with files:** File handling refers to the ability of a program to interact with files stored on your computer's file system (e.g., hard drive, SSD).
*   **Performing operations on files:** This includes operations like:
    *   **Reading data from files:**  Getting information *from* a file into your program. (Input)
    *   **Writing data to files:**  Saving information *from* your program into a file. (Output)
    *   **Creating new files.**
    *   **Deleting files.**
    *   **Appending data to existing files.**
    *   ...and more.
---

### Introduction to File Handling üìÇ
# Introduction to File Handling in Python

### **Why is File Handling Important?**

*   **Persistent data storage:** Files allow you to store data *persistently*, meaning data is saved even after your program ends.  Variables in your program only hold data in memory while the program is running; files provide long-term storage.
*   **Data input and output:**  Files are crucial for:
    *   **Reading input data:**  Loading data from files to be processed by your program (e.g., configuration files, data datasets, user input from files).
    *   **Saving output data:**  Storing results generated by your program into files (e.g., reports, processed data, user-generated content).
*   **Interacting with external data:**  Files are a common way for programs to exchange data with other programs, systems, and users.
---

### Introduction to File Handling üìÇ
# Introduction to File Handling in Python
### **Common File Types We'll Focus On (Initially):**

*   **Text Files (`.txt`):** Files containing plain text data (characters, words, lines). These are the simplest type of files to work with.
*   **(Later) Comma Separated Values (CSV) Files (`.csv`):**  Files used to store tabular data (like spreadsheets) in a text-based format, where values are separated by commas.  We may briefly introduce these later.

**In this section, we will focus on the fundamental operations of reading and writing **text files** in Python.**

**Next: Let's learn the basic steps involved in file handling: Opening, Reading/Writing, and Closing Files!** ‚û°Ô∏è

---

### Basic File Handling Steps üë£
# Basic Steps in File Handling

**Working with files in Python generally involves these three fundamental steps:**

**1. Opening a File:**

*   **Prepare the file for operations:** Before you can read from or write to a file, you need to *open* it.
*   **`open()` function:**  You use the built-in `open()` function to open a file.
*   **Specify file path and mode:** When opening a file, you need to provide:
    *   **File path:**  The location of the file on your computer (e.g., `"my_document.txt"`, `"data/input.csv"`).
    *   **Mode:**  Indicates what you want to do with the file (e.g., `"r"` for read, `"w"` for write, `"a"` for append).
---

### Basic File Handling Steps üë£
# Basic Steps in File Handling

**Working with files in Python generally involves these three fundamental steps:**

**2. Reading from or Writing to the File:**

*   **Perform operations:** Once the file is open, you can perform the desired operations:
    *   **Reading:**  Read data from the file into your program (e.g., using `read()`, `readline()`, `readlines()`).
    *   **Writing:** Write data from your program into the file (e.g., using `write()`).
---

### Basic File Handling Steps üë£
# Basic Steps in File Handling

**Working with files in Python generally involves these three fundamental steps:**

**3. Closing the File:**

*   **Release resources and save changes:** After you are finished working with a file, it's crucial to **close** it.
*   **`close()` method:**  You use the `close()` method of the file object to close the file.
*   **Importance of closing:** Closing a file:
    *   Releases system resources used by the open file.
    *   Ensures that any changes you've made to the file are properly saved to disk.
    *   Prevents potential data corruption or errors.
---

### Basic File Handling Steps üë£
# Basic Steps in File Handling

**Working with files in Python generally involves these three fundamental steps:**

**Example - Basic File Handling Flow (Conceptual):**

```python
# 1. Open the file (for reading in this example)
file = open("my_file.txt", "r")

# 2. Read data from the file
file_contents = file.read()
print(file_contents)

# 3. Close the file
file.close()
```

**Important:  It's highly recommended to use the `with open(...)` statement for file handling (as we'll see next), as it automatically handles file closing, even if errors occur.**

**Next: Let's learn how to open files using the `open()` function in detail! ‚û°Ô∏è**

---

### Opening Files - The `open()` Function ‚öôÔ∏è
# Opening Files in Python - Using the `open()` Function
**The `open()` function is your primary tool for opening files in Python.**

**Syntax of the `open()` function:**

```python
file_object = open(file_path, mode)
```

- `open(...)`**:**  The built-in Python function for opening files.
- `file_path` **(required):**  A string specifying the path to the file you want to open. This can be:
    - **Relative path:** Path relative to the current working directory (e.g., `"my_file.txt"`, `"data/report.csv"`).
    - **Absolute path:** Full path from the root directory (e.g., `"/Users/yourname/documents/my_file.txt"` on macOS/Linux, `"C:\\Users\\YourName\\Documents\\my_file.txt"` on Windows).
---

### Opening Files - The `open()` Function ‚öôÔ∏è
# Opening Files in Python - Using the `open()` Function
**The `open()` function is your primary tool for opening files in Python.**

**Syntax of the `open()` function (cntd.):**

- `mode` **(optional, but highly recommended):** A string specifying the *mode* in which you want to open the file. Common modes include:

    - `"r"` **(Read mode):** Opens the file for reading. This is the **default mode** if you don't specify a mode. The file must exist. If the file does not exist, it will raise `FileNotFoundError`.
    - `"w"` **(Write mode):** Opens the file for writing.
        - **Creates a new file if it doesn't exist.**
        - **Overwrites the file if it already exists** (be careful!).
    - `"a"` **(Append mode):** Opens the file for writing, but **appends** to the end of the file if it exists. Creates a new file if it doesn't exist.
---

### Opening Files - The `open()` Function ‚öôÔ∏è
# Opening Files in Python - Using the `open()` Function
**The `open()` function is your primary tool for opening files in Python.**

**Syntax of the `open()` function (cntd.):**

- `mode` **(optional, but highly recommended) (cntd.):**
    - `"x"` **(Exclusive creation mode):** Creates a new file, but fails (raises `FileExistsError`) if the file already exists.
    - `"b"` **(Binary mode):** Used to open files in binary mode (e.g., for images, audio files). We'll focus on text files for now, so we won't use `"b"` immediately.
    - `"t"` **(Text mode):** Default mode for text files. Opens the file in text mode (interprets data as text - encoding is platform dependent). Often implied, but can be specified as `"rt"`, `"wt"`, etc.
    - **`"+"` (Updating mode):** Can be combined with other modes (like`"r+"`,`"w+"`,`"a+"`) to allow both reading and writing.
---

### Opening Files - The `open()` Function ‚öôÔ∏è
# Opening Files in Python - Using the `open()` Function
**The `open()` function is your primary tool for opening files in Python.**

- `file_object`**:** The `open()` function returns a **file object** (also sometimes called a file handle). This object represents the open file and provides methods for reading and writing to it.
---

### Opening Files - The `open()` Function ‚öôÔ∏è
<!-- # Opening Files in Python - Using the `open()` Function -->

```py
**Example - Opening files in different modes:**
# Open a file for reading (read mode "r") - file must exist
try:
    file_read = open("my_document.txt", "r")
    print("File 'my_document.txt' opened for reading.")
except FileNotFoundError:
    print("Error: 'my_document.txt' not found!")

# Open a file for writing (write mode "w") - creates or overwrites
file_write = open("output.txt", "w")
print("File 'output.txt' opened for writing (or created).")

# Open a file for appending (append mode "a") - creates if not exists, appends if exists
file_append = open("log.txt", "a")
print("File 'log.txt' opened for appending (or created).")

# Note: We are just *opening* the files here, not yet reading or writing to them.
# We'll do that in the next slides.
```

**After opening a file, it's crucial to close it properly using `file_object.close()` or, even better, use the `with open(...)` statement (next slide) for automatic closing.**

**Next: Let's learn about the best practice for file handling: the `with open(...)` statement! ‚û°Ô∏è**

---

### `with open(...)` - Automatic File Closing üõ°Ô∏è
# Ensuring Automatic File Closing

**Using the `with open(...)` statement is the recommended and safest way to work with files in Python. It ensures that files are automatically closed, even if errors occur.**

**Syntax of `with open(...)`:**

```python
with open(file_path, mode) as file_object:
    # Code block to work with the file (read or write operations)
    # ... file operations using file_object ...
    # ... more file operations ...
# File is automatically closed when you exit the 'with' block (indentation ends)
```
---

### `with open(...)` - Automatic File Closing üõ°Ô∏è
# Ensuring Automatic File Closing

**Using the `with open(...)` statement is the recommended and safest way to work with files in Python. It ensures that files are automatically closed, even if errors occur.**

**Explanation of `with open(...)`:**

- `with open(file_path, mode) as file_object:`**:**
    - `with` **keyword:** Starts the `with` statement.
    - `open(file_path, mode)`**:** Opens the file using the `open()` function (same as before, specifying file path and mode).
    - `as file_object`**:** Assigns the returned file object to the variable `file_object` (you can choose any valid variable name).
    - **Colon `:`:** Indicates the start of the `with` block.
---

### `with open(...)` - Automatic File Closing üõ°Ô∏è
# Ensuring Automatic File Closing

**Using the `with open(...)` statement is the recommended and safest way to work with files in Python. It ensures that files are automatically closed, even if errors occur.**

**Explanation of `with open(...)` (cntd. ):**

- **Indented Code Block:** The code that you want to execute *while the file is open* is indented under the `with` statement. This is where you perform your read or write operations using the `file_object`.
- **Automatic Closing: Crucially, when the code execution exits the `with` block (i.e., the indentation ends), Python automatically and reliably *closes* the file.** This happens regardless of whether the code in the `with` block runs successfully or encounters an error.
---

### `with open(...)` - Automatic File Closing üõ°Ô∏è
# Ensuring Automatic File Closing

**Using the `with open(...)` statement is the recommended and safest way to work with files in Python. It ensures that files are automatically closed, even if errors occur.**

**Benefits of using `with open(...)`:**

- **Automatic File Closing:** You don't need to remember to call `file.close()` explicitly. Python handles it for you automatically.
- **Exception Safety:** Even if an error (exception) occurs within the `with` block, the file is still guaranteed to be closed properly. This prevents resource leaks and data corruption.
- **cleaner and More Readable Code:** `with open(...)` makes your file handling code cleaner, more concise, and less error-prone.
---

### `with open(...)` - Automatic File Closing üõ°Ô∏è
<!-- # Ensuring Automatic File Closing -->

**Using the `with open(...)` statement is the recommended and safest way to work with files in Python. It ensures that files are automatically closed, even if errors occur.**

**Example - Reading a file using `with open(...)`:**

```py
try: # Added try-except to handle FileNotFoundError if file doesn't exist
    with open("my_document.txt", "r") as file: # Open in read mode "r"
        contents = file.read() # Read the entire file content
        print("File contents:\n", contents)
    # File is automatically closed here when exiting the 'with' block

except FileNotFoundError:
    print("Error: 'my_document.txt' not found!")


# You don't need to call file.close() - it's done automatically by 'with'
```

**Best Practice: Always use `with open(...)` for file handling in Python whenever possible. It's safer, cleaner, and more robust!**

**Next: Let's explore different ways to read data from files (reading modes and methods)! ‚û°Ô∏è**

---

## Reading from Files - Different Methods üìñ
# Reading Data from Files

**Once you have opened a file in read mode (`"r"`), Python provides several methods to read its contents.**

**Common File Reading Methods:**

*   **`read()`:**
    *   **Reads the *entire* file content as a single string.**
    *   If you call `read()` again after reading the whole file, it will return an empty string (`""`) because the file "cursor" (position) will be at the end of the file.
    *   Use `read()` when you want to load the entire file content into memory at once (suitable for smaller files).

    ```python
    with open("my_file.txt", "r") as file:
        all_contents = file.read() # Read the entire file into 'all_contents'
        print("--- Entire File Content (using read()) ---")
        print(all_contents)
    ```
---

<!-- ## Reading from Files - Different Methods üìñ -->
# Reading Data from Files

**Once you have opened a file in read mode (`"r"`), Python provides several methods to read its contents.**

**Common File Reading Methods:**
*   **`readline()`:**
    *   **Reads a *single line* from the file.**
    *   Each time you call `readline()`, it reads the next line, including the newline character (`\n`) at the end of the line (if present).
    *   Returns an empty string (`""`) when it reaches the end of the file.
    *   Useful for processing files line by line.

    ```python
    with open("my_file.txt", "r") as file:
        line1 = file.readline() # Read the first line
        line2 = file.readline() # Read the second line
        print("--- First two lines (using readline()) ---")
        print("Line 1:", line1)
        print("Line 2:", line2)
    ```

*   **`readlines()`:**
    *   **Reads *all lines* from the file and returns them as a *list of strings*.**
    *   Each string in the list represents a line, including the newline character at the end.
    *   Use `readlines()` to get all lines into a list for further processing.

    ```python
    with open("my_file.txt", "r") as file:
        all_lines = file.readlines() # Read all lines into a list 'all_lines'
        print("--- All lines as a list (using readlines()) ---")
        for line in all_lines:
            print(line.strip()) # Print each line after removing newline character
    ```

*   **Iterating Directly over the File Object:**
    *   **Treat the file object as an iterator:** You can directly loop through a file object in a `for` loop.
    *   **Reads file line by line (efficiently):**  In each iteration, the loop yields the next line from the file. This is memory-efficient, especially for large files, as it reads lines one at a time, not the entire file into memory.
    *   Each line includes the newline character.

    ```python
    with open("my_file.txt", "r") as file:
        print("--- Iterating over lines (for loop) ---")
        for line in file: # Iterate directly over the file object
            print(line.strip()) # Process each line (remove newline character)
    ```

**Choose the reading method that best suits your needs based on how you want to process the file's data (entire file, line by line, or all lines as a list).**

**Next: Let's practice reading from files with a "Your Turn" exercise!** ‚û°Ô∏è

---

### Your Turn: File Reading Exercise ‚úçÔ∏è
# Analyze a Text File

**Time to practice reading data from a text file!**

**Exercise: Analyze `poem.txt`**

**Task:**

1.  **Create a text file named `poem.txt`** (if you don't already have one). You can create this file in the same directory where you are running your Jupyter Notebook, or in a location you can easily access.
2.  **Add some text content to `poem.txt`.**  You can copy a short poem, some song lyrics, or just a few paragraphs of any text you like.  For example:

    ```text
    The woods are lovely, dark and deep,
    But I have promises to keep,
    And miles to go before I sleep,
    And miles to go before I sleep.
    ```
---

### Your Turn: File Reading Exercise ‚úçÔ∏è
<!-- # Analyze a Text File -->

<!-- **Time to practice reading data from a text file!** -->

**Exercise: Analyze `poem.txt`**

3.  **Write a Python script in your Jupyter Notebook to do the following:**

    *   **Open `poem.txt` in read mode (`"r"`) using `with open(...)`.**
    *   **Read the *entire content* of `poem.txt` using `read()` and print it to the console.**
    *   **Read the *first two lines* of `poem.txt` using `readline()` twice, and print each line.**
    *   **Read *all lines* of `poem.txt` into a *list* using `readlines()`.**
    *   **Iterate through the list of lines obtained from `readlines()` and print each line, but this time, remove the newline character (`\n`) from EOLs before printing (using `line.strip()`).**
    *   **Finally, iterate through the file object *directly* (using `for line in file:`), and print each line, again removing the newline character using `line.strip()`.**
---

### Your Turn: File Reading Exercise ‚úçÔ∏è
# Analyze a Text File

**This exercise will give you hands-on practice with all the file reading methods we just learned!** üöÄ

**After completing the exercise, observe the output from each reading method and make sure you understand how each method reads and processes the file content.**

**Next: Let's move on to writing data to files! ‚û°Ô∏è**

---

## Writing to Files - `"w"` and `"a"` Modes ‚úçÔ∏è
# Writing Data to Files

**To write data to files in Python, you need to open the file in either **write mode (`"w"`)** or **append mode (`"a"`)**.**

**1. Write Mode (`"w"`):**

*   **Creates a new file or overwrites:**
    *   If the file specified in `open(..., "w")` **does not exist**, write mode `"w"` will **create a new empty file**.
    *   If the file **already exists**, write mode `"w"` will **completely overwrite** the existing file's content.  **Use with caution if you don't want to lose existing data!**

---

## Writing to Files - `"w"` and `"a"` Modes ‚úçÔ∏è
# Writing Data to Files

**To write data to files in Python, you need to open the file in either **write mode (`"w"`)** or **append mode (`"a"`)**.**

**1. Write Mode (`"w"`):**

*   **`write()` method:**  You use the `write()` method of the file object to write strings to the file.

    ```python
    with open("output_file.txt", "w") as file: # Open in write mode "w"
        file.write("This is the first line.\n") # Write a string to the file
        file.write("This is the second line.\n")
        file.write("More text to write...\n")
    # File is automatically closed when exiting 'with'
    print("Data written to 'output_file.txt' in write mode.")
    ```
---

## Writing to Files - `"w"` and `"a"` Modes ‚úçÔ∏è
# Writing Data to Files

**To write data to files in Python, you need to open the file in either **write mode (`"w"`)** or **append mode (`"a"`)**.**

**2. Append Mode (`"a"`):**

*   **Creates a new file or appends to existing:**
    *   If the file specified in `open(..., "a")` **does not exist**, append mode `"a"` will **create a new empty file**.
    *   If the file **already exists**, append mode `"a"` will **add (append)** the new data to the **end** of the existing file content.  Existing content is preserved.
---

## Writing to Files - `"w"` and `"a"` Modes ‚úçÔ∏è
# Writing Data to Files

**To write data to files in Python, you need to open the file in either **write mode (`"w"`)** or **append mode (`"a"`)**.**

**2. Append Mode (`"a"`):**

*   **`write()` method:**  You also use the `write()` method in append mode to write strings to the file.

    ```python
    with open("log_file.txt", "a") as file: # Open in append mode "a"
        file.write("--- New log entry ---\n") # Write a log entry
        file.write("Timestamp: 2023-10-27 10:30:00\n")
        file.write("Event: User login successful\n")
    # File is automatically closed
    print("Data appended to 'log_file.txt' in append mode.")
    ```
---

## Writing to Files - `"w"` and `"a"` Modes ‚úçÔ∏è
# Writing Data to Files

**To write data to files in Python, you need to open the file in either **write mode (`"w"`)** or **append mode (`"a"`)**.**

**Key Differences between Write (`"w"`) and Append (`"a"`):**

*   **`"w"` (Write): Overwrites** existing file content or creates a new file.
*   **`"a"` (Append): Adds to the end** of an existing file (preserves existing content) or creates a new file if it doesn't exist.

**Important Note:** The `write()` method in Python file objects is used to write *strings* to the file. If you have other data types (numbers, lists, etc.), you'll need to convert them to strings before writing them using `str()`.

**Next: Let's do a "Your Turn" exercise to practice writing to files in both write and append modes!** ‚û°Ô∏è

---

### Your Turn: File Writing Exercise ‚úçÔ∏è
# Your Turn! File Writing Exercise - Writing to Files

**Let's get some hands-on practice writing data to files!**

**Exercise 1: Create and Write to `my_notes.txt`**

**Task:**

1.  **Write a Python script to create a new text file named `my_notes.txt` using write mode (`"w"`).**
2.  **Inside the `with open(...)` block, write the following lines to `my_notes.txt`:**
    ```text
    My To-Do List:
    - Learn more about Python file handling
    - Practice OOP concepts
    - Start thinking about project ideas
    ```
    Write each line using a separate `file.write()` statement, and remember to include newline characters (`\n`) at the end of each line to create line breaks in the file.
---

### Your Turn: File Writing Exercise ‚úçÔ∏è
# Your Turn! File Writing Exercise - Writing to Files

**Let's get some hands-on practice writing data to files!**

**Exercise 1: Create and Write to `my_notes.txt`**

**Task:**

3.  **After running your script, check if the `my_notes.txt` file has been created in the same directory as your script, and verify that it contains the text you wrote.**

---

### Your Turn: File Writing Exercise ‚úçÔ∏è
<!-- # Your Turn! File Writing Exercise - Writing to Files -->

<!-- **Let's get some hands-on practice writing data to files!** -->

**Exercise 2: Append to `log.txt`**

1.  **Assume you have an existing file named `log.txt`** (or create an empty one if it doesn't exist).
2.  **Write a Python script to open `log.txt` in append mode (`"a"`).**
3.  **Inside the `with open(...)` block, append the following lines to `log.txt`:**
    ```text
    --- Log Entry ---
    Timestamp: [Current Timestamp - you can hardcode a timestamp for simplicity, e.g., 2023-10-27 11:00:00]
    Action: Exercise 2 completed - Appended to log.txt
    ```
    Again, use separate `file.write()` statements and include newline characters.
4.  **Run your script multiple times.**
5.  **Open `log.txt` and observe that each time you run the script, a new log entry is appended to the end of the file, and the previous content is preserved.**

**Complete these exercises in your Jupyter Notebook. Experiment with writing different kinds of text and using both write (`"w"`) and append (`"a"`) modes to understand how they behave! üöÄ**

**Next: We're almost at the end of Session 6. Let's quickly summarize what we've covered here! ‚û°Ô∏è**

---

## Session 6 Summary - OOP & File Handling ‚úÖ
# Session 6 Wrap-up: Introduction to OOP & File Handling

**Congratulations on completing Session 6!** üéâ  We covered a lot of ground in this combined session, introducing two important areas:

**Object-Oriented Programming (OOP) - Introduction:**

*   **What is OOP:** A programming paradigm focused on "objects" that combine data and functions.
*   **Why OOP:** Modularity, reusability, encapsulation, abstraction, maintainability.
*   **Classes:** Blueprints or templates for creating objects.
*   **Objects (Instances):** Concrete entities created from classes, each with its own attributes and methods.
*   **Attributes:** Data associated with an object.
*   **Methods:** Functions that objects can perform, operating on their data.
*   **Basic Syntax:** `class`, `__init__`, `self`, dot notation (`.`).
*   **(Briefly) Encapsulation and Abstraction:** Key OOP principles for good design.
---

## Session 6 Summary - OOP & File Handling ‚úÖ
# Session 6 Wrap-up: Introduction to OOP & File Handling

**File Handling - Introduction:**

*   **What is File Handling:** Interacting with files for persistent data storage and I/O.
*   **Basic Steps:** Opening, reading/writing, and closing files.
*   **`open()` function:** Used to open files, specifying file path and mode (`"r"`, `"w"`, `"a"`, etc.).
*   **`with open(...)` statement:** Recommended for automatic and safe file closing.
*   **File Reading Methods:** `read()`, `readline()`, `readlines()`, and iterating over the file object.
*   **File Writing Methods:** `write()` (used in `"w"` and `"a"` modes).
*   **Write Mode (`"w"`):** Creates or overwrites files.
*   **Append Mode (`"a"`):** Appends to existing files or creates new ones.
---

## Session 6 Summary - OOP & File Handling ‚úÖ
# Session 6 Wrap-up: Introduction to OOP & File Handling

**Key Takeaway from Session 6:**

*   You've started your journey into Object-Oriented Programming and learned the basics of defining classes and creating objects in Python.
*   You now know how to perform fundamental file operations in Python: opening, reading from, and writing to text files.
*   These are crucial skills that will enable you to build more structured and interactive Python programs! üí™

**Next: That's the end of Session 6! Let's officially conclude this session on the next slide!** ‚û°Ô∏è

**(Session 6: OOP Intro & File Handling - Session Summary)**

---

## Session 6 - End üéâ

<!-- # Session 6 Complete!  Introduction to OOP & File Handling ‚úÖ -->

<!-- **You have reached the end of Session 6: "Introduction to Object-Oriented Programming (OOP) & File Handling"!**

**Excellent work!** You've made a great start in understanding Object-Oriented Programming and gained essential skills for working with files in Python. -->

**Key achievements in this session:**

*   You now have a foundational understanding of Object-Oriented Programming concepts: Classes, Objects, Attributes, Methods.
*   Defining simple Python classes and create objects from them.
*   Understanding the basic principles of Encapsulation and Abstraction in OOP.
*   Opening files in Python using the `open()` function and the `with open(...)` statement.
*   Reading data from text files using `read()`, `readline()`, `readlines()`, and by iterating over file objects.
*   You can write data to text files using write mode (`"w"`) and append mode (`"a"`).

**You are now equipped to start structuring your Python code using objects and classes, and you can make your programs interact with external files for data storage and retrieval!**

**Ready to move on to the next session?**

**Up Next: Session 7 - Error Handling - Exceptions!** üöÄ

