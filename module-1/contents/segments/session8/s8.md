---
transition: slide-left
align: centre
title: Advanced Topics - Iterators, Generators & Decorators
layout: section
---

# Session 8: 
## Advanced Topics - Iterators, Generators & Decorators

---

### Session 8 - Welcome to Advanced Topics! üöÄ
# Iterators, Generators & Decorators

**Welcome!** üéâ In this session, we will explore three powerful and elegant features of Python that will significantly enhance your programming abilities:

1.  **Iterators and Iterables:**  We'll dive deep into the concept of iteration in Python, understand what makes objects iterable, and learn how iterators work behind the scenes. We'll also see how to create our own custom iterators.

2.  **Generators:** We will discover generators - a special type of function that allows you to create sequences of values lazily and efficiently. Generators are memory-friendly and are incredibly useful for working with large datasets or infinite sequences.

3.  **Decorators:**  We will explore decorators, a highly useful and elegant feature for adding functionality to functions and methods in a reusable way. Decorators are a powerful tool for metaprogramming and for writing cleaner, more modular code.
---

### Session 8 - Welcome to Advanced Topics! üöÄ
# Iterators, Generators & Decorators

**In this Session 8, we will cover:**

*   **Iteration in Python: Iterables and Iterators**
    *   Understanding the iterator protocol (`__iter__` and `__next__` methods).
    *   Built-in iterables and creating custom iterators.
*   **Generators**
    *   Generator functions and the `yield` keyword.
    *   Generator expressions.
    *   Benefits of generators: Memory efficiency and lazy evaluation.
*   **Decorators**
    *   Decorator functions and the `@decorator` syntax.
    *   Function wrappers and how decorators modify function behavior.
    *   Practical examples: timing, logging, input validation decorators.
---

### Session 8 - Welcome to Advanced Topics! üöÄ
# Iterators, Generators & Decorators

**By the end of Session 8, you will have a solid understanding of iterators, generators, and decorators, and you will be able to use these advanced techniques to write more efficient, elegant, and powerful Python code!** üí™

**Let's start by exploring Iterators and Iterables in Python!** ‚û°Ô∏è

---

### Iterables - What Can Be Iterated? üö∂‚Äç‚ôÄÔ∏è
# Iterables: What Objects Can You Iterate Over?

**In Python, the concept of "iterable" is fundamental to iteration.  Simply put: An **iterable** is any Python object that you can loop over, or iterate through, using a `for` loop.**

**What makes an object Iterable?**

*   **Supports Iteration:**  An object is considered iterable if it is capable of returning its members one at a time.
*   **`__iter__()` method:**  Technically, an object is iterable if it defines or inherits an `__iter__()` method. This method is responsible for returning an *iterator* object for the iterable. (We'll explore iterators in detail on the next slide).
---
layout: two-cols-header
---

### Session 8 - Welcome to Advanced Topics! üöÄ
<!-- # Iterators, Generators & Decorators -->
**Common Built-in Iterables in Python:**
::left::
<!-- Python has many built-in data types that are iterable. You've been using iterables all along! Examples include: -->

*   **Lists:**
    ```python
    my_list = [1, 2, 3, 4, 5]
    for item in my_list: # Lists are iterable
        print(item)
    ```

*   **Tuples:**
    ```python
    my_tuple = (10, 20, 30)
    for value in my_tuple: # Tuples are iterable
        print(value)
    ```
*   **Strings:**
    ```python
    my_string = "Python"
    for character in my_string: # Strings are iterable 
                            # (iterate over characters)
        print(character)
    ```
::right::
*   **Dictionaries:** (Iterate over *keys* by default)
    ```python
    my_dict = {"a": 1, "b": 2, "c": 3}
    for key in my_dict: # Dictionaries are iterable (iterates over keys)
        print(key)

    for value in my_dict.values(): # Iterate over values
        print(value)
    for key, value in my_dict.items(): # Iterate over key-value pairs
        print(key, value)
    ```

*   **Sets:**
    ```python
    my_set = {100, 200, 300}
    for element in my_set: # Sets are iterable
        print(element)
    ```
---

### Session 8 - Welcome to Advanced Topics! üöÄ
<!-- # Iterators, Generators & Decorators -->
**Common Built-in Iterables in Python:**


*   **Files:** (Iterate over lines in a file)
    ```python
    with open("poem.txt", "r") as file:
        for line in file: # File objects are iterable (iterate over lines)
            print(line.strip())
    ```

*   **Ranges:** (Generated sequence of numbers)
    ```python
    for number in range(5): # range() creates an iterable sequence
        print(number) # Output: 0, 1, 2, 3, 4
    ```

**When you use a `for` loop in Python, you are always iterating over an iterable object!**  The `for` loop automatically handles the process of getting an iterator from the iterable and fetching elements one by one.

**Next: Let's understand what Iterators are and how they work behind the scenes!** ‚û°Ô∏è

---

### Iterators - The Engine of Iteration ‚öôÔ∏è
# Iterators: The Engine Behind Iteration

**While iterables are objects you *can* iterate over, **iterators** are the actual objects that *perform* the iteration.**

**What is an Iterator?**

*   **Object that produces values sequentially:** An iterator is an object that produces the next value in a sequence when you ask it to, and keeps track of its current position in the sequence.
*   **Stateful:** Iterators are *stateful*. They remember their position in the iteration. Once you've retrieved a value from an iterator, it moves to the next position, and you cannot go back to previous values (unless you create a new iterator).
---

### Iterators - The Engine of Iteration ‚öôÔ∏è
<!-- # Iterators: The Engine Behind Iteration -->

<!-- **While iterables are objects you *can* iterate over, **iterators** are the actual objects that *perform* the iteration.** -->

**What is an Iterator?**

*   **Iterator Protocol:** Iterators in Python must implement the **iterator protocol**, which consists of two essential methods:
    1.  **`__iter__()`:**  This method is required for both iterables and iterators.
        *   For an *iterable*, the `__iter__()` method returns an *iterator* object for that iterable.
        *   For an *iterator* itself, the `__iter__()` method simply returns `self` (the iterator object itself).  This makes iterators also iterable.
    2.  **`__next__()`:** This method is the core of an iterator.
        *   It returns the **next element** in the sequence.
        *   When there are **no more elements** to return, it **raises a `StopIteration` exception**. This exception signals to the iteration loop (e.g., `for` loop) that the iteration is complete.
---

### Iterators - The Engine of Iteration ‚öôÔ∏è
# Iterators: The Engine Behind Iteration

**While iterables are objects you *can* iterate over, **iterators** are the actual objects that *perform* the iteration.**

**How Iteration Works Behind the Scenes (Simplified):**

When you write a `for` loop like `for item in iterable: ...`:

1.  **`iter(iterable)` is called:**  Python first calls the `iter()` function on the `iterable`. This function in turn calls the `iterable`'s `__iter__()` method to get an *iterator* object.
2.  **`next(iterator)` is called repeatedly:**  Inside the loop, Python repeatedly calls the `next()` function on the *iterator*. This function calls the `iterator`'s `__next__()` method to get the next element.
3.  **`StopIteration` signals end:**  The loop continues until the `__next__()` method raises a `StopIteration` exception. Python catches this exception and knows that the iteration is finished, so the loop terminates gracefully.
---

### Iterators - The Engine of Iteration ‚öôÔ∏è
# Iterators: The Engine Behind Iteration

**While iterables are objects you *can* iterate over, **iterators** are the actual objects that *perform* the iteration.**

**Example: Manual Iteration using `iter()` and `next()`:**

```python
my_list = [10, 20, 30] # An iterable (list)

my_iterator = iter(my_list) # Get an iterator from the list

print(next(my_iterator)) # Get the first element (calls my_iterator.__next__())  Output: 10
print(next(my_iterator)) # Get the second element (calls my_iterator.__next__()) Output: 20
print(next(my_iterator)) # Get the third element (calls my_iterator.__next__())  Output: 30

# print(next(my_iterator)) # Uncommenting this line would raise StopIteration
```

**Iterators are the workhorses that power iteration in Python. They provide a standardized way to access elements of a sequence one by one, making for loops and other iteration constructs possible!**

**Next: Let's create our own Custom Iterators to solidify our understanding! ‚û°Ô∏è**

---

### Custom Iterators - Building Your Own üõ†Ô∏è
# Creating Custom Iterators

**One of the powerful aspects of Python's iterator protocol is that you can create your own custom iterators for any data structure or sequence you define.**

**To create a custom iterator, you need to define a class that fulfills the iterator protocol:**

1.  **`__iter__(self)` method:**
    *   This method should return the iterator object itself (`return self`).  This is what makes your class *both* iterable and an iterator.

2.  **`__next__(self)` method:**
    *   This method defines the logic to produce the next item in the sequence.
    *   It should:
        *   Calculate and return the next value.
        *   If there are no more items, it **must raise the `StopIteration` exception**.
---

### Custom Iterators - Building Your Own üõ†Ô∏è
# Creating Custom Iterators

<!-- **One of the powerful aspects of Python's iterator protocol is that you can create your own custom iterators for any data structure or sequence you define.** -->

**Example: Creating a Custom Iterator for a Range (similar to `range()`)**

```python
class MyRangeIterator:
    def __init__(self, start, end):
        self.current = start
        self.end = end

    def __iter__(self):
        return self # Iterator returns itself

    def __next__(self):
        if self.current < self.end:
            value = self.current # Get current value
            self.current += 1    # Increment for next value
            return value         # Return current value
        else:
            raise StopIteration  # Signal end of iteration
```
---

### Custom Iterators - Building Your Own üõ†Ô∏è
# Creating Custom Iterators

**One of the powerful aspects of Python's iterator protocol is that you can create your own custom iterators for any data structure or sequence you define.**

```py
# Example usage:
my_range = MyRangeIterator(1, 5) # Create custom range iterator

for number in my_range: # Use it in a 'for' loop (works because MyRangeIterator is iterable)
    print(number) # Output: 1, 2, 3, 4

# Manual iteration:
my_range2_iterator = iter(MyRangeIterator(10, 13)) # Get iterator explicitly
print(next(my_range2_iterator)) # Output: 10
print(next(my_range2_iterator)) # Output: 11
print(next(my_range2_iterator)) # Output: 12
# print(next(my_range2_iterator)) # Would raise StopIteration
```
---

### Custom Iterators - Building Your Own üõ†Ô∏è
# Creating Custom Iterators

**One of the powerful aspects of Python's iterator protocol is that you can create your own custom iterators for any data structure or sequence you define.**
<!-- <br> -->

**Explanation of `MyRangeIterator`:**

- `__init__`: Initializes the start and end of the range.
- `__iter__`: Returns `self`, making `MyRangeIterator` instances iterators themselves.
- `__next__`:
    - Checks if `self.current` is still within the range (`< self.end`).
    - If yes, returns the `self.current` value and increments `self.current` for the next call.
    - If no (range is exhausted), raises `StopIteration` to signal the end.

**By implementing `__iter__` and `__next__`, you can make any class iterable and control the iteration behavior, creating custom sequences and data traversal patterns!**

**Next: Let's do a "Your Turn" exercise to create our own custom iterator! ‚û°Ô∏è**

---
layout: two-cols-header
---

### Your Turn: Custom Iterator Exercise ‚úçÔ∏è
# Your Turn! Build a Vowel Iterator

**Let's create a custom iterator to practice implementing the iterator protocol!**

::left::

**Exercise: Create a `VowelIterator`**
**Task:**

1.  **Create a class called `VowelIterator`:**
    *   The constructor `__init__(self, text)` should take a string `text` as input.
    *   Inside `__init__`, store the input `text` and initialize an index to keep track of the current position in the string.
2.  **Implement the `__iter__(self)` method:**
    *   This method should return `self` (the iterator object itself).
::right::

3.  **Implement the `__next__(self)` method:**
    *   This method should iterate through the input `text` and return the *next vowel* (a, e, i, o, u) found in the text.
    *   Skip over any non-vowel characters.
    *   If there are no more vowels in the text, it should raise `StopIteration`.
    *   Consider both uppercase and lowercase vowels (a, e, i, o, u, A, E, I, O, U).
---

### Your Turn: Custom Iterator Exercise ‚úçÔ∏è
<!-- # Your Turn! Build a Vowel Iterator -->

<!-- **Let's create a custom iterator to practice implementing the iterator protocol!** -->

**Example Usage:**

```python
# Example Usage:
text_string = "Hello Programming in Python"
vowel_iter = VowelIterator(text_string) # Create a VowelIterator

for vowel in vowel_iter: # Iterate using a for loop
    print(vowel) # Expected output: e, o, o, a, i, i, o

# Manual iteration:
vowel_iter2 = VowelIterator("Quick Brown Fox")
print(next(vowel_iter2)) # Output: u
print(next(vowel_iter2)) # Output: i
print(next(vowel_iter2)) # Output: o
# ... and so on until StopIteration
```

**Write the `VowelIterator` class in your Jupyter Notebook. Test it with different strings to ensure it correctly iterates only through the vowels in the text and raises `StopIteration` when finished! üöÄ**

**Experiment and have fun!**

**Now; we'll move on to Generators - another powerful iteration tool in Python! ‚û°Ô∏è**

---
layout: two-cols-header
---

### Generators - Introduction to Lazy Sequences üí´

# Generators: Creating Sequences Lazily

**Generators are a special type of function in Python that allows you to create iterators in a very concise and memory-efficient way.**

::left::

**What are Generators?**

*   **Functions that `yield` values:** Generators are defined like regular Python functions, but instead of `return`, they use the `yield` keyword to produce a sequence of values.
*   **Lazy evaluation:** Generators produce values *on demand*, one at a time, only when they are needed during iteration. They don't generate and store the entire sequence in memory all at once.

::right::
*   **Memory efficiency:** Because of lazy evaluation, generators are very memory-efficient, especially when dealing with very large or potentially infinite sequences. They only hold the state needed to produce the *next* value, not the entire sequence.
*   **Iterators automatically:** Generator functions automatically create iterator objects. When you call a generator function, it returns a generator object, which you can then iterate over using a `for` loop or `next()`.
---

### Your Turn: Custom Iterator Exercise ‚úçÔ∏è
# Your Turn! Build a Vowel Iterator

**Let's create a custom iterator to practice implementing the iterator protocol!**

**Key Concept: The `yield` Keyword**

*   **`yield` vs. `return`:**
    *   `return` terminates a function and returns a value.
    *   `yield` pauses the function's execution, "yields" a value to the caller, and saves the function's state so it can be resumed from where it left off the next time `next()` is called on the generator.
*   **Multiple `yield` statements:** A generator function can have multiple `yield` statements. Each `yield` statement produces a value in the sequence.
*   **Implicitly creates an iterator:** When a function contains `yield`, it becomes a generator function and implicitly creates an iterator.
---

### Your Turn: Custom Iterator Exercise ‚úçÔ∏è
# Your Turn! Build a Vowel Iterator

<!-- **Let's create a custom iterator to practice implementing the iterator protocol!** -->

**Example: A Simple Generator Function**

```python
def number_generator(n):
    """Generates numbers from 0 to n-1."""
    i = 0
    while i < n:
        yield i # Yield the current value of i
        i += 1

# Example Usage:
my_generator = number_generator(5) # Create a generator object

for number in my_generator: # Iterate over the generator
    print(number) # Output: 0, 1, 2, 3, 4

# Manual iteration:
my_generator2 = number_generator(3)
print(next(my_generator2)) # Output: 0
print(next(my_generator2)) # Output: 1
print(next(my_generator2)) # Output: 2
# print(next(my_generator2)) # Would raise StopIteration
```
---

### Your Turn: Custom Iterator Exercise ‚úçÔ∏è
<!-- # Your Turn! Build a Vowel Iterator -->

<!-- **Let's create a custom iterator to practice implementing the iterator protocol!** -->

<!-- **Example: A Simple Generator Function** -->

**Explanation of `number_generator`:**

- When `number_generator(5)` is called, it returns a generator object (not executes the function body immediately).
- When the `for` loop starts iterating, or when `next()` is called, the function body starts executing from the beginning.
- When `yield i` is encountered, the current value of `i` is "yielded" (returned) to the loop, and the function's state is saved.
- The next time the loop asks for the next value, the function resumes from where it was paused (right after the `yield` statement), and continues until the next `yield` or until the function finishes (implicitly raising `StopIteration`).

**Generators provide a clean and efficient way to work with sequences, especially when dealing with large amounts of data or when you need to generate values on the fly!**

---

### Generator Functions - Defining and Using ‚öôÔ∏è

# Generator Functions: Defining and Using Them

**Let's learn how to define and use generator functions in Python.**

**Defining a Generator Function:**

To create a generator function, you use the `def` keyword like a regular function, but with one crucial difference:  you include at least one `yield` statement in the function body.

**Example: Defining a generator function `countdown`:**

```python
def countdown_generator(start):
    """Generates a countdown sequence from start to 1."""
    while start > 0:
        yield start # Yield the current value
        start -= 1
    yield "Blast off!" # Yield a final message

# Example of calling the generator function:
countdown = countdown_generator(5) # Creates a generator object
```
---
layout: two-cols-header
---

### Generator Functions - Defining and Using ‚öôÔ∏è

# Generator Functions: Defining and Using Them

**Using a Generator Function:**

When you call a generator function, it doesn't execute the function body immediately. Instead, it returns a **generator object** which could be iterated to get the values produced by the `yield` statements.
::left::
**Iterating through the `countdown` generator:**
```py
# Iterate over the generator object
for val in countdown: 
    print(val)
# Output: 5, 4, 3, 2, 1, Blast off!
```

**Key points:**
- Generator functions use `yield` to produce values.
- Calling a generator function returns a generator object (iterator).

::right::
**Manual iteration with `next()`:**
```py
countdown2 = countdown_generator(1)
print(next(countdown2)) # Output: 1
print(next(countdown2)) # Output: Blast off!
print(next(countdown2)) # Would raise StopIteration
```

<!-- **Key points:** -->
<!-- - Generator functions use `yield` to produce values.
- Calling a generator function returns a generator object (iterator). -->
- Iteration (e.g., `for` loop, `next()`) drives the generator function's execution, yielding values one at a time.

**Generators are excellent for creating sequences on demand, saving memory and improving efficiency.**

<!-- **Next: Let's explore Generator Expressions - a more concise way to create generators! ‚û°Ô∏è** -->

---

### Generator Expressions - Concise Generators ‚ö°Ô∏è
# Generator Expressions: Creating Generators Concisely

**Generator expressions provide an even more compact way to create generator objects, especially for simple generator logic.**

**What are Generator Expressions?**

*   **Similar to List Comprehensions:** Generator expressions have a syntax very similar to list comprehensions, but they use parentheses `()` instead of square brackets `[]`.
*   **Create generators, not lists:**  Unlike list comprehensions which create and return a *list*, generator expressions create and return a *generator object*.
*   **Lazy evaluation (like generator functions):** Generator expressions also produce values lazily, on demand, and are memory-efficient.
---

### Generator Expressions - Concise Generators ‚ö°Ô∏è
# Generator Expressions: Creating Generators Concisely

**Generator expressions provide an even more compact way to create generator objects, especially for simple generator logic.**
**Syntax of a Generator Expression:**

```python
(expression for item in iterable if condition)
```

- `( )` **Parentheses:** Generator expressions are enclosed in parentheses `()`.
- `expression`**:** The value to be yielded for each item.
- `for item in iterable`**:** Iterates over an iterable (like a list, range, etc.).
- `if condition` **(optional):** Filters items based on a condition (optional).
---

### Generator Expressions - Concise Generators ‚ö°Ô∏è
# Generator Expressions: Creating Generators Concisely

**Generator expressions provide an even more compact way to create generator objects, especially for simple generator logic.**

**Example: Generator Expression for Squares**
```py
# List comprehension (eager - creates a list in memory)
squares_list = [x*x for x in range(5)] # Creates a list of squares
print(squares_list) # Output: [0, 1, 4, 9, 16]


# Generator expression (lazy - creates a generator object)
squares_generator = (x*x for x in range(5)) # Creates a generator
print(squares_generator) # Output: <generator object <genexpr> at ...>


# Iterating through the generator:
for square in squares_generator:
    print(square) # Output: 0, 1, 4, 9, 16
```
---

### Generator Expressions - Concise Generators ‚ö°Ô∏è
<!-- # Generator Expressions: Creating Generators Concisely -->

<!-- **Generator expressions provide an even more compact way to create generator objects, especially for simple generator logic.** -->

**Example: Generator Expression with a Condition (even numbers squared)**

```py
even_squares_generator = (x*x for x in range(10) if x % 2 == 0) # Squares of even numbers

for square in even_squares_generator:
    print(square) # Output: 0, 4, 16, 36, 64
```

**Benefits of Generator Expressions:**

- **Conciseness:** More compact syntax than generator functions for simple generators.
- **Memory efficiency:** Lazy evaluation, like generator functions.
- **Readability (for simple cases):** Can be more readable than full generator functions for straightforward generation logic.

**Generator expressions are a handy tool for creating simple generators quickly and efficiently, especially when you need lazy evaluation and memory savings.**

**Next: Let's compare Generator Functions and Generator Expressions and see when to use each! ‚û°Ô∏è**

---

### Generator Expressions vs. Generator Functions ‚öñÔ∏è
# Generator Expressions vs. Generator Functions

**Both generator expressions and generator functions are powerful tools for creating iterators with lazy evaluation. Let's compare them to understand when to use each.**

**Generator Expressions:**

*   **Concise syntax:**  `(expression for item in iterable if condition)`
*   **Best for:** Simple generators, often for short, self-contained generation logic.
*   **Readability:** Very readable for straightforward transformations and filtering.
*   **Single expression generators:** Ideal for cases where the generator logic can be expressed in a single expression.
*   **Example:**
    ```python
    # Generator expression for even numbers squared
    even_squares_gen_expr = (x*x for x in range(10) if x % 2 == 0)
    for sq in even_squares_gen_expr:
        print(sq)
    ```
---
layout: two-cols-header
---

### Generator Expressions vs. Generator Functions ‚öñÔ∏è

**Both generator expressions and generator functions are powerful tools for creating iterators with lazy evaluation. Let's compare them to understand when to use each.**

::left::

**Generator Functions:**

*   **Full function definition with `def` and `yield`**.
*   **Best for:** More complex generator logic, multi-step generation processes, or when you need more control over the generator's behavior.
*   **Readability:**  More readable for complex logic or when you need to break down the generation process into multiple steps or use control flow (if/else, loops, etc.) within the generator.

::right::

*   **Can contain multiple `yield` statements and more complex code.**
*   **Example:**
    ```python
    def countdown_generator(start):
        """Generator for countdown sequence."""
        while start > 0:
            yield start
            start -= 1
        yield "Blast off!"

    for val in countdown_generator(3):
        print(val)
    ```
---

### Generator Expressions vs. Generator Functions ‚öñÔ∏è

**When to Choose Which:**

*   **Use Generator Expressions:**
    *   For simple, one-liner generators.
    *   When you need a quick, concise way to generate a sequence.
    *   When readability is enhanced by the compact syntax for simple transformations.
*   **Use Generator Functions:**
    *   For more complex generation logic that requires multiple steps, control flow, or more elaborate state management.
    *   When readability benefits from breaking down the logic into a function structure with comments and potentially multiple `yield` points.
    *   When you need the full power and flexibility of a function definition within your generator.

**In many cases, both generator expressions and generator functions can achieve the same result. The choice often comes down to code clarity, complexity of the generation logic, and personal preference.**

<!-- **Next.‚û°Ô∏è** -->

---
layout: two-cols-header
---

### Your Turn: Generator Exercise ‚úçÔ∏è
# Your Turn! Generator Exercise - Practice Generators
**Time to practice creating and using generators!**

::left::

**Exercise 1: Create a Generator Function**

<!-- **Task:** -->

1.  **Write a generator function called `even_number_generator(limit)` that:**
    *   Takes an integer `limit` as input.
    *   **Yields all even numbers from 0 up to (and including) `limit`.**
    *   For example, if `limit` is 10, it should yield: 0, 2, 4, 6, 8, 10.

::right::

2.  **Test your generator function:**
    *   Create a generator object by calling `even_number_generator(20)`.
    *   Iterate through the generator using a `for` loop and print each yielded even number.
    *   Also, test manual iteration using `next()` to get the first few even numbers.
---
layout: two-cols-header
---

### Your Turn: Generator Exercise ‚úçÔ∏è
# Your Turn! Generator Exercise - Practice Generators
**Time to practice creating and using generators!**

::left::

**Exercise 2: Create a Generator Expression**

<!-- **Task:** -->

1.  **Create a generator expression that generates the squares of the first 15 odd numbers.**
    *   First, generate the first 15 odd numbers (e.g., 1, 3, 5, ..., 29).
    *   Then, square each of these odd numbers.
    *   Use a generator expression to combine these two steps in a concise way.

::right::

2.  **Test your generator expression:**
    *   Iterate through the generator expression using a `for` loop and print each squared odd number.
    *   Convert the generator expression to a list using `list()` to see all the generated squared odd numbers at once.

**Complete these exercises in your Jupyter Notebook to solidify your understanding of generator functions and generator expressions! üöÄ**

---

### Benefits of Generators - Memory Efficiency ü•á
# Benefits of Generators: Memory Efficiency

**One of the most significant advantages of generators is their memory efficiency, especially when working with large sequences of data.**

**Generators are Memory-Efficient Because They are Lazy:**

*   **Lazy Evaluation:** Generators produce values only when they are asked for (on demand), during iteration. They don't compute and store all values in memory upfront.
*   **Value Generation on Demand:**  Instead of creating an entire list or tuple in memory, a generator computes and yields one item at a time, then "forgets" it (in terms of memory usage).  It only remembers the state necessary to produce the *next* item.
*   **No large data structures in memory:** Generators avoid creating and holding large lists or other data structures in memory to store entire sequences.
---

### Benefits of Generators - Memory Efficiency ü•á
# Benefits of Generators: Memory Efficiency

**One of the most significant advantages of generators is their memory efficiency, especially when working with large sequences of data.**

**Contrast with Lists (Eager Evaluation):**

*   **Lists store all elements in memory:** When you create a list comprehension or a regular list, all elements are computed and stored in memory *immediately*.
*   **Memory consumption increases with list size:** The memory used by a list grows linearly with the number of elements it contains. For very large lists, this can lead to high memory usage and potential memory errors.
---

### Benefits of Generators - Memory Efficiency ü•á
# Benefits of Generators: Memory Efficiency

**One of the most significant advantages of generators is their memory efficiency, especially when working with large sequences of data.**

**Example: Comparing List Comprehension and Generator Expression for Memory Usage**

```python
import sys

# List comprehension - creates a list in memory
large_list = [x for x in range(1000000)] # 1 million numbers
list_memory_size = sys.getsizeof(large_list)
print(f"Memory size of list (1 million items): {list_memory_size} bytes") # Output: ~8MB or more


# Generator expression - creates a generator (lazy)
large_generator = (x for x in range(1000000)) # Generator for 1 million numbers
generator_memory_size = sys.getsizeof(large_generator)
print(f"Memory size of generator (for 1 million items): {generator_memory_size} bytes") 
# Output: ~128 bytes (constant size!)
```
---

### Benefits of Generators - Memory Efficiency ü•á
# Benefits of Generators: Memory Efficiency

**One of the most significant advantages of generators is their memory efficiency, especially when working with large sequences of data.**

**Explanation:**

- The list comprehension `large_list` creates a list containing 1 million numbers. This list occupies a significant amount of memory (several megabytes).
- The generator expression `large_generator` creates a generator object that *can* produce 1 million numbers, but it doesn't store them all in memory. The generator object itself is very small and has a constant memory footprint (around 128 bytes), regardless of the potential size of the sequence it can generate.

**Generators are ideal for processing large datasets, reading large files, or working with infinite sequences where you cannot or do not want to load everything into memory at once. They are a cornerstone of memory-efficient Python programming!**

---

### Generators - Use Cases - Data Pipelines üîó

# Use Cases for Generators: Data Pipelines

**Generators are exceptionally well-suited for building data pipelines, especially when dealing with large datasets that don't fit into memory.**

**What is a Data Pipeline?**

*   **Series of processing stages:** A data pipeline is a sequence of operations or stages that data flows through, with the output of one stage becoming the input to the next.
*   **Data transformation:** Each stage in the pipeline typically performs some transformation, filtering, or processing on the data.
*   **Example: Read, process, filter, analyze, output:** A common pipeline might involve reading data from a source, cleaning and transforming it, filtering it based on criteria, performing analysis, and then outputting the results.
---

### Generators - Use Cases - Data Pipelines üîó

# Use Cases for Generators: Data Pipelines

**Generators are exceptionally well-suited for building data pipelines, especially when dealing with large datasets that don't fit into memory.**

**Generators in Data Pipelines: Memory Efficiency and Streaming**

*   **Streaming Data:** Generators enable "streaming" data through the pipeline. Data is processed in chunks or items, one at a time, rather than loading the entire dataset into memory.
*   **Memory Efficiency:** Each stage of the pipeline can be implemented as a generator.  The output of one generator (stage) is fed as input to the next generator (stage) *without* storing intermediate results in large lists or data structures in memory.
*   **Chaining Generators:** You can chain generator functions and expressions together to create complex data processing pipelines in a very memory-efficient way.
---

### Generators - Use Cases - Data Pipelines üîó

# Use Cases for Generators: Data Pipelines

**Generators are exceptionally well-suited for building data pipelines, especially when dealing with large datasets that don't fit into memory.**

**Example: Data Pipeline with Generators (Simplified)**

```python
def read_large_dataset(file_path):
    """Generator to read data from a large file line by line."""
    with open(file_path, 'r') as file:
        for line in file:
            yield line.strip() # Yield each line (stripped of whitespace)

def filter_data(data_stream, keyword):
    """Generator to filter data lines containing a keyword."""
    for line in data_stream:
        if keyword in line:
            yield line # Yield lines containing the keyword

def process_data(data_stream):
    """Generator to process each data line (e.g., convert to uppercase)."""
    for line in data_stream:
        yield line.upper() # Yield processed lines
```
---

### Generators - Use Cases - Data Pipelines üîó

# Use Cases for Generators: Data Pipelines

**Generators are exceptionally well-suited for building data pipelines, especially when dealing with large datasets that don't fit into memory.**

```py
# Example pipeline usage:
file_path = "large_data_file.txt" # Assume this is a very large file

pipeline = process_data(filter_data(read_large_dataset(file_path), "important"))

for processed_line in pipeline: # Iterate through the pipeline
    print(processed_line) # Process and print lines that contain "important"
```
---

### Generators - Use Cases - Data Pipelines üîó

# Use Cases for Generators: Data Pipelines

**Generators are exceptionally well-suited for building data pipelines, especially when dealing with large datasets that don't fit into memory.**

**Explanation:**

- `read_large_dataset` reads a file line by line (generator).
- `filter_data` filters lines based on a keyword (generator, takes input from `read_large_dataset`).
- `process_data` processes each line (e.g., uppercase, generator, takes input from filter_data).
- `pipeline` chains these generators together.
- The `for` loop iterates through the *entire* pipeline, processing data in a memory-efficient stream, without loading the entire dataset into memory at any stage.

**Generators are fundamental for building efficient and scalable data processing systems in Python!**

---

### Decorators - Introduction - Function Enhancement ü™Ñ

# Decorators: Enhancing Functions with Elegance

**Decorators are a powerful and elegant feature in Python that allows you to modify or enhance the behavior of functions or methods in a reusable way.**

**What are Decorators?**

*   **"Wrappers" around functions:** Decorators are essentially "wrappers" that you can place *around* a function to add extra functionality *before*, *after*, or *around* the original function's execution.
*   **Modify function behavior without changing its core:** Decorators let you augment the behavior of a function without directly modifying its source code. This promotes cleaner, more modular, and reusable code.
*   **Reusable enhancement:** Once you define a decorator, you can apply it to multiple functions to add the same enhancement to all of them, avoiding code duplication.
*   **Syntax using `@`:**  Python provides a special `@` syntax to apply decorators, making the code very readable and intuitive.
---

### Decorators - Introduction - Function Enhancement ü™Ñ

# Decorators: Enhancing Functions with Elegance

**Decorators are a powerful and elegant feature in Python that allows you to modify or enhance the behavior of functions or methods in a reusable way.**

**Analogy: Gift Wrapping üéÅ**

Think of a decorator like gift wrapping:

*   **The original function is the gift itself.** It has its core functionality (what the gift *is*).
*   **The decorator is like the wrapping paper and ribbon.** It adds extra things *around* the gift - presentation, style, maybe a tag, etc. (enhancements like logging, timing, validation).
*   **You "wrap" the gift (function) with the wrapping paper (decorator) to enhance it.**  The gift itself remains the same, but it's now presented or enhanced in some way.
---

### Decorators - Introduction - Function Enhancement ü™Ñ

# Decorators: Enhancing Functions with Elegance

**Decorators are a powerful and elegant feature in Python that allows you to modify or enhance the behavior of functions or methods in a reusable way.**

**Common Use Cases for Decorators:**

*   **Logging:**  To automatically log function calls, arguments, and return values.
*   **Timing:** To measure the execution time of functions.
*   **Input Validation:** To check function arguments before the function executes.
*   **Access Control/Authorization:** To control who can access certain functions.
*   **Caching:** To memoize (cache) function results for performance optimization.

**Decorators are a key tool for writing more modular, reusable, and maintainable Python code, especially when you need to add common functionalities to multiple functions.**

---

### Decorators - Basic Structure - The Wrapper Pattern üéÅ

# Decorator Structure: The Wrapper Pattern

### Basic Decorator Structure

```python
# Example: Basic Decorator Structure
def my_decorator(func): # Decorator function takes a function as argument
    def wrapper():     # Defines a wrapper function
        # --- Code BEFORE original function ---
        print("Before function call.")
        func()         # Call the original function
        # --- Code AFTER original function ---
        print("After function call.")
    return wrapper      # Returns the wrapper function

@my_decorator          # Apply the decorator using @ syntax
def say_hello():       # Original function
    print("Hello!")

# Calling the decorated function:
say_hello()
```

**Explanation**
Decorator `my_decorator` takes a function `func` and returns `wrapper`. `@my_decorator` above `say_hello` is equivalent to `say_hello = my_decorator(say_hello).`

---

### Decorators - Example - Timing Function Execution ‚è±Ô∏è
# Decorator Example: Timing Function Execution

**Let's create a practical decorator to measure the execution time of a function.**

**Decorator for Timing:**

```python
import time

def timer_decorator(func):
    """Decorator to measure and print the execution time of a function."""
    def wrapper(*args, **kwargs): # Wrapper function to accept any arguments
        start_time = time.time()
        result = func(*args, **kwargs) # Call original function
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"Function '{func.__name__}' executed in {execution_time:.4f} seconds")
        return result
    return wrapper
```
---
layout: two-cols
---

### Decorators - Example - Timing Function Execution ‚è±Ô∏è
<!-- # Decorator Example: Timing Function Execution -->

<!-- **Let's create a practical decorator to measure the execution time of a function.** -->

**Applying the `@timer_decorator`:**
```py
@timer_decorator # Apply the timer_decorator to this func
def slow_function():
    """Simulates a slow function 
    by sleeping for 2 seconds"""
    time.sleep(2)

@timer_decorator # Apply to another function as well
def fast_function(n):
    """Calculates the sum of numbers up to n (quickly)."""
    return sum(range(n+1))
```

**Example Usage:**
```py
slow_function() # Call the decorated slow function
# Call the decorated fast function
result_fast = fast_function(100000) 
print(f"Result from fast_function: {result_fast}")
```

**Explanation:** **---------------------------------------->**
::right::


- `timer_decorator` takes a function `func` as input.
- `wrapper` function inside `timer_decorator` records start time, calls the original `func`, records the end time, calculates execution time, prints it, and returns the result of the original function.
- `@timer_decorator` syntax applies the decorator to `slow_function` and `fast_function`. Now, whenever you call `slow_function()` or `fast_function()`, they'll be "wrapped" by the `timer_decorator` and their execution time will be measured and printed.

**Decorators like `timer_decorator` are pretty useful for adding cross-cutting concerns ( timing, logging etc.) to your functions in a clean and reusable manner!**

---

### Decorators - Example - Logging Function Calls ü™µ
# Decorator Example: Logging Function Calls

**Let's create another practical decorator, this time for logging function calls. This decorator will automatically log when a function is called and what arguments it receives.**

**Decorator for Logging Calls:**

```python
import functools # For @functools.wraps (preserves function metadata)

def log_calls_decorator(func):
    """Decorator to log function calls with arguments."""
    @functools.wraps(func) # Preserves original function's info
    def wrapper(*args, **kwargs):
        log_message = f"Calling function: '{func.__name__}' with arguments: args={args}, kwargs={kwargs}"
        print(f"LOG: {log_message}") # Or use a proper logging module
        result = func(*args, **kwargs)
        print(f"LOG: Function '{func.__name__}' returned: {result}")
        return result
    return wrapper
```
---
layout: two-cols
---

### Decorators - Logging Function Calls ü™µ
<!-- # Decorator Example: Logging Function Calls -->

**Applying the `@log_calls_decorator`:**
```py
@log_calls_decorator
def add(x, y):
    """Adds two numbers and returns the sum."""
    return x + y

@log_calls_decorator
def greet(name, greeting="Hello"):
    """Greets a person with a message."""
    return f"{greeting}, {name}!"
```

**Example Usage:**
```python
# Call the decorated add function
sum_result = add(5, 3) 
print("Sum:", sum_result)

# Call decorated greet
greeting_message = greet(   "Alice", 
                            greeting="Good morning") 
print("Greeting:", greeting_message)
```

::right::
**Explanation:**

- `log_calls_decorator` takes a function `func`.
- `wrapper` function:
    - Constructs a log message including function name, `args`, and `kwargs`.
    - Prints the log message (in a real application, you'd use a proper logging module instead of `print`).
    - Calls the original function func and stores the result.
    - Prints a log message with the return value.
    - Returns the result of the original function.

---
layout: two-cols
---

### Decorators - Logging Function Calls ü™µ
<!-- # Decorator Example: Logging Function Calls -->

**Applying the `@log_calls_decorator`:**
```py
@log_calls_decorator
def add(x, y):
    """Adds two numbers and returns the sum."""
    return x + y

@log_calls_decorator
def greet(name, greeting="Hello"):
    """Greets a person with a message."""
    return f"{greeting}, {name}!"
```

**Example Usage:**
```py
# Call the decorated add function
sum_result = add(5, 3) 
print("Sum:", sum_result)

# Call decorated greet
greeting_message = greet("Alice", 
                        greeting="Good morning") 
print("Greeting:", greeting_message)
```

::right::

**Explanation: (cntd.)**

- `@functools.wraps(func)`: This decorator from the `functools` module is important. It helps preserve metadata of the original function (`__name__`, `__doc__`, etc.) when using decorators, which is good practice.
- `@log_calls_decorator` is applied to `add` and `greet`, so every time you call `add` or `greet`, the logging decorator will be executed.


**Decorators like `log_calls_decorator` are invaluable for adding debugging, auditing, or monitoring capabilities to your functions without modifying their core logic!**

---

### Decorators - Example - Input Validation ‚úÖ
# Decorator Example: Input Validation

**Let's create a decorator for input validation. This decorator will check if the arguments passed to a function meet certain criteria before the function executes.**

**Decorator for Input Validation:**

```python
def validate_input_decorator(input_types): # Decorator factory - takes type dictionary
    """Decorator to validate function input types based on a type dictionary."""
    def decorator(func): # Actual decorator takes the function
        def wrapper(*args, **kwargs):
            # Input type validation logic:
            for arg_name, expected_type in input_types.items():
                arg_value = kwargs.get(arg_name) # Get argument value by name
                if arg_name not in kwargs or not isinstance(arg_value, expected_type):
                    raise TypeError(f"Argument '{arg_name}' must be of type {expected_type.__name__}, 
                    but got {type(arg_value).__name__ if arg_name in kwargs else 'missing'}")
            return func(*args, **kwargs) # Call original function if validation passes
        return wrapper
    return decorator # Return the decorator
```
---

### Decorators - Example - Input Validation ‚úÖ
# Decorator Example: Input Validation

**Let's create a decorator for input validation. This decorator will check if the arguments passed to a function meet certain criteria before the function executes.**

**Applying `@validate_input_decorator`:**
```py
@validate_input_decorator(input_types={"name": str, "age": int}) # Define type rules
def create_user_profile(name, age):
    """Creates a user profile if inputs are valid."""
    return {"name": name, "age": age}

@validate_input_decorator(input_types={"numbers": list}) # Type rule for 'numbers' argument
def calculate_sum_of_list(numbers):
    """Calculates the sum of numbers in a list (validates input is a list)."""
    return sum(numbers) if numbers else 0
```
---

### Decorators - Example - Input Validation ‚úÖ
# Decorator Example: Input Validation

**Let's create a decorator for input validation. This decorator will check if the arguments passed to a function meet certain criteria before the function executes.**

**Example Usage (with valid and invalid inputs):**

```py
user1 = create_user_profile(name="Alice", age=30) # Valid inputs
print("User profile 1:", user1)

# user2 = create_user_profile(name="Bob", age="twenty") # Invalid age type - would raise TypeError

valid_sum = calculate_sum_of_list(numbers=[1, 2, 3, 4]) # Valid list input
print("Valid sum:", valid_sum)

# invalid_sum = calculate_sum_of_list(numbers="not a list") # Invalid input type - would raise TypeError
```
---

### Decorators - Example - Input Validation ‚úÖ
# Decorator Example: Input Validation

**Let's create a decorator for input validation. This decorator will check if the arguments passed to a function meet certain criteria before the function executes.**

**Explanation:**

- `validate_input_decorator` is a d*ecorator factory*. It takes `input_types` (a dictionary mapping argument names to expected types) as an argument and then returns the actual decorator. This allows you to configure the validation rules per function.
- The `@validate_input_decorator(...)` syntax is used with a call to the decorator factory, passing in the `input_types` dictionary for each function.
- The `wrapper` function within the decorator does the type checking based on the `input_types` dictionary. If validation fails, it raises a `TypeError`. If it passes, it calls the original function.

**Decorator factories like `validate_input_decorator` make decorators even more flexible and reusable, allowing you to parameterize their behavior!**

---
layout: two-cols
---

### Your Turn: Decorator Exercise ‚úçÔ∏è

<!-- # Your Turn! Create a `@repeat_decorator` -->

<!-- **Time to create your own decorator! Let's build a decorator that repeats the execution of a function a specified number of times.** -->

**Exercise: Create a `@repeat_decorator(num_times)`**

**Task:**

1.  **Create a decorator factory function called `repeat_decorator(num_times)`:**
    *   It should take an integer `num_times` as an argument. This will be the number of times the decorated function should be executed.
    *   Inside `repeat_decorator`, define the actual decorator function (let's call it `decorator`).
    *   The `decorator` function should take a function `func` as input.
    *   Inside `decorator`, define the `wrapper` function.

::right::

2.  **Implement the `wrapper` function within your decorator:**
    *   The `wrapper` function should execute the original function `func`  `num_times`.
    *   For each execution, it should print a message *before* calling the function (e.g., "Repeating function call {count}...").
    *   After all repetitions, it should print a message (e.g., "Function execution repeated {num_times} times.").
    *   **Important:** For simplicity in this exercise, assume the original function `func` does not return any value (or its return value is not important for repetition). Just focus on repeating the execution and printing the messages.
---

### Decorators - Example - Input Validation ‚úÖ
# Decorator Example: Input Validation

**Let's create a decorator for input validation. This decorator will check if the arguments passed to a function meet certain criteria before the function executes.**

3.  **Test your `@repeat_decorator`:**
    *   Create a sample function (e.g., `my_function()`) that prints a simple message (e.g., "Inside my_function.").
    *   Apply your `@repeat_decorator(3)` to `my_function` to repeat it 3 times.
    *   Call the decorated `my_function()` and observe the output.
    *   Test with different values for `num_times` (e.g., `@repeat_decorator(5)`, `@repeat_decorator(1)`).

**Complete this exercise in your Jupyter Notebook to practice building and using decorator factories! üöÄ**
---

### Session 8 Summary - Iterators, Generators & Decorators ‚úÖ

# Session 8 Wrap-up: Iterators, Generators & Decorators
<br>

**Congratulations on completing Session 8: "Advanced Topics - Iterators, Generators, and Decorators"!** üéâ You've now explored some of Python's most powerful and elegant features for iteration and function enhancement.
---
layout: two-cols-header
---

### Session 8 Summary - Iterators, Generators & Decorators ‚úÖ

<!-- # Session 8 Wrap-up: Iterators, Generators & Decorators -->
::left::
**Key Concepts Covered in Session 8:**

**1. Iterables:**

*   Objects you can iterate over (e.g., lists, tuples, strings, dictionaries, sets, files, ranges).
*   Technically, objects that implement the `__iter__()` method.

::right::

**2. Iterators:**
*   Objects that perform the actual iteration, producing values sequentially.
*   Stateful: remember their position.
*   Implement the iterator protocol: `__iter__()` (returns self) and `__next__()` (returns next value or raises `StopIteration`).

*   Created using `iter(iterable)`. Values retrieved using `next(iterator)`.
*   Custom iterators: you can build your own by defining classes with `__iter__` and `__next__`.
---
layout: two-cols-header
---

### Session 8 Summary - Iterators, Generators & Decorators ‚úÖ

::left::

**3. Generators:**

*   Functions that use `yield` to produce a sequence of values lazily (on demand).
*   Generator functions return generator objects (which are iterators).
*   Memory-efficient: generate values one at a time, don't store entire sequences.
*   Generator expressions: concise syntax for simple generators using `()`.
*   Use cases: data pipelines, memory-efficient processing of large datasets, concurrency.

::right::

**4. Decorators:**

*   "Wrappers" to enhance functions without changing their core logic.
*   Reusable function enhancements (logging, timing, validation, etc.).
*   Defined as functions that take a function as input and return a modified function (wrapper).
*   Applied using the `@decorator_name` syntax.
*   Decorator factories: create parameterized decorators.
---

### Session 8 Summary - Iterators, Generators & Decorators ‚úÖ


**Key Takeaway from Session 8:**

*   You now understand the fundamental concepts of iteration in Python and the distinction between iterables and iterators.
*   You can create and use custom iterators and generators for efficient sequence generation and data processing.
*   You can use decorators to elegantly enhance function behavior and add reusable functionalities to your code.

**These advanced features will enable you to write more efficient, elegant, and powerful Python programs!** üí™

---

## Slide 160: Session 8 - Session End üéâ

# Iterators, Generators & Decorators ‚úÖ

**You have reached the end of Session 8: "Advanced Topics - Iterators, Generators, and Decorators"!**

**Congratulations!** ü•≥ You've tackled some of the more advanced and sophisticated concepts in Python in this session, and you've done a fantastic job!

**Key achievements in Session 8:**

*   You now have a solid understanding of Iterables and Iterators and how iteration works in Python.
*   You can create and utilize custom Iterators to control iteration behavior.
*   You have mastered Generators - both generator functions and generator expressions - for memory-efficient sequence generation.
*   You can effectively use Decorators to enhance and modify functions in a clean and reusable way, and you've seen practical examples like timing, logging, and input validation.

**You are now equipped with even more powerful tools to write efficient, elegant, and professional-grade Python code!** üí™